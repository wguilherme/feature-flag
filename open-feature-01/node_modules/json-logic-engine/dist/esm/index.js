// @ts-check
// Note: Each of these iterators executes synchronously, and will not "run in parallel"
// I am supporting filter, reduce, some, every, map
async function filter (arr, iter) {
  const result = []
  let index = 0
  for (const item of arr) {
    if (await iter(item, index++, arr)) result.push(item)
  }
  return result
}

async function some (arr, iter) {
  let index = 0
  for (const item of arr) {
    if (await iter(item, index++, arr)) return true
  }
  return false
}

async function every (arr, iter) {
  let index = 0
  for (const item of arr) {
    if (!(await iter(item, index++, arr))) return false
  }
  return true
}

async function map (arr, iter) {
  const result = []
  let index = 0
  for (const item of arr) {
    result.push(await iter(item, index++, arr))
  }
  return result
}

async function reduce (arr, iter, defaultValue) {
  if (arr.length === 0) {
    if (typeof defaultValue !== 'undefined') {
      return defaultValue
    }
    throw new Error('Array has no elements.')
  }

  const start = typeof defaultValue === 'undefined' ? 1 : 0
  let data = start ? arr[0] : defaultValue

  for (let i = start; i < arr.length; i++) {
    data = await iter(data, arr[i])
  }

  return data
}

const asyncIterators = {
  filter,
  some,
  every,
  map,
  reduce
}

// @ts-check

const Sync = Symbol.for('json_logic_sync')
const Compiled = Symbol.for('json_logic_compiled')
const EfficientTop = Symbol.for('json_logic_efficientTop')

/**
 * Checks if an item is synchronous.
 * This allows us to optimize the logic a bit
 * further so that we don't need to await everything.
 *
 * @param {*} item
 * @returns {Boolean}
 */
function isSync (item) {
  if (typeof item === 'function') return item[Sync] === true
  if (Array.isArray(item)) return item.every(isSync)
  if (item && item.asyncMethod && !item.method) return false
  return true
}

const Constants = {
  Sync,
  EfficientTop,
  isSync
}

// @ts-check
function declareSync (obj, sync = true) {
  obj[Sync] = sync
  return obj
}

/**
 * Coerces a value into an array.
 * This is used for unary value operations.
 */
function coerceArray (value, skip = false) {
  if (skip) return value
  return Array.isArray(value) ? value : [value]
}

const counts = new WeakMap()

/**
 * Counts the number of arguments a function has; paying attention to the function's signature
 * to avoid edge cases.
 * This is used to allow for compiler optimizations.
 * @param {(...args: any[]) => any} fn
 * @returns {number}
 */
function countArguments (fn) {
  if (!fn || typeof fn !== 'function' || !fn.length) return 0
  if (!counts.has(fn)) counts.set(fn, _countArguments(fn))
  return counts.get(fn)
}

/**
 * Counts the number of arguments a function has; paying attention to the function's signature.
 * This is the internal implementation that does not use a WeakMap.
 * @param {(...args: any[]) => any} fn
 * @returns {number}
 */
function _countArguments (fn) {
  if (!fn || typeof fn !== 'function' || !fn.length) return 0
  let fnStr = fn.toString()
  if (fnStr[0] !== '(' && fnStr[0] !== 'f') return 0
  fnStr = fnStr.substring(fnStr.indexOf('('), fnStr.indexOf('{')).replace(/=>/g, '')

  // regex to check for "..." or "="
  const regex = /\.{3}|=/
  if (regex.test(fnStr)) return 0
  return fn.length
}

// @ts-check

/**
 * Provides a simple way to compile logic into a function that can be run.
 * @param {string[]} strings
 * @param  {...any} items
 * @returns {{ [Compiled]: string }}
 */
function compileTemplate (strings, ...items) {
  let res = ''
  const buildState = this
  for (let i = 0; i < strings.length; i++) {
    res += strings[i]
    if (i < items.length) {
      if (typeof items[i] === 'function') {
        this.methods.push(items[i])
        if (!isSync(items[i])) buildState.asyncDetected = true
        res += (isSync(items[i]) ? '' : ' await ') + 'methods[' + (buildState.methods.length - 1) + ']'
      } else if (items[i] && typeof items[i][Compiled] !== 'undefined') res += items[i][Compiled]
      else res += buildString(items[i], buildState)
    }
  }
  return { [Compiled]: res }
}

/**
 * @typedef BuildState
 * Used to keep track of the compilation.
 * @property {*} [engine]
 * @property {Object} [notTraversed]
 * @property {Object} [methods]
 * @property {Object} [state]
 * @property {Array} [processing]
 * @property {*} [async]
 * @property {Array} [above]
 * @property {Boolean} [asyncDetected]
 * @property {*} [values]
 * @property {Boolean} [avoidInlineAsync]
 * @property {string} [extraArguments]
 * @property {(strings: string[], ...items: any[]) => { compiled: string }} [compile] A function that can be used to compile a template.
 */

/**
 * Checks if the value passed in is a primitive JS object / value.
 * @param {*} x
 * @returns
 */
function isPrimitive (x, preserveObject) {
  if (typeof x === 'number' && (x === Infinity || x === -Infinity || Number.isNaN(x))) return false
  return (
    x === null ||
    x === undefined ||
    ['Number', 'String', 'Boolean'].includes(x.constructor.name) ||
    (!preserveObject && x.constructor.name === 'Object')
  )
}

/**
 * Checks if the method & its inputs are deterministic.
 * @param {*} method
 * @param {*} engine
 * @param {BuildState} buildState
 * @returns
 */
function isDeterministic$1 (method, engine, buildState) {
  if (Array.isArray(method)) {
    return method.every((i) => isDeterministic$1(i, engine, buildState))
  }

  if (method && typeof method === 'object') {
    const func = Object.keys(method)[0]
    const lower = method[func]

    if (engine.isData(method, func)) return true
    if (lower === undefined) return true
    if (!engine.methods[func]) throw new Error(`Method '${func}' was not found in the Logic Engine.`)

    if (engine.methods[func].traverse === false) {
      return typeof engine.methods[func].deterministic === 'function'
        ? engine.methods[func].deterministic(lower, buildState)
        : engine.methods[func].deterministic
    }

    return typeof engine.methods[func].deterministic === 'function'
      ? engine.methods[func].deterministic(lower, buildState)
      : engine.methods[func].deterministic &&
          isDeterministic$1(lower, engine, buildState)
  }

  return true
}

/**
 * Checks if the method & its inputs are synchronous.
 * @param {*} method
 * @param {*} engine
 */
function isDeepSync (method, engine) {
  if (!engine.async) return true

  if (Array.isArray(method)) return method.every(i => isDeepSync(i, engine))

  if (typeof method === 'object') {
    const func = Object.keys(method)[0]

    const lower = method[func]
    if (!isSync(engine.methods[func])) return false

    if (engine.methods[func].traverse === false) {
      if (typeof engine.methods[func][Sync] === 'function' && engine.methods[func][Sync](method, { engine })) return true
      return false
    }

    return isDeepSync(lower, engine)
  }

  return true
}

/**
 * Builds the string for the function that will be evaluated.
 * @param {*} method
 * @param {BuildState} buildState
 * @returns
 */
function buildString (method, buildState = {}) {
  const {
    notTraversed = [],
    async,
    processing = [],
    values = [],
    engine
  } = buildState
  function pushValue (value, preserveObject = false) {
    if (isPrimitive(value, preserveObject)) return JSON.stringify(value)
    values.push(value)
    return `values[${values.length - 1}]`
  }

  if (Array.isArray(method)) {
    let res = ''
    for (let i = 0; i < method.length; i++) {
      if (i > 0) res += ','
      res += buildString(method[i], buildState)
    }
    return '[' + res + ']'
  }

  let asyncDetected = false

  function makeAsync (result) {
    buildState.asyncDetected = buildState.asyncDetected || asyncDetected
    if (async && asyncDetected) return `await ${result}`
    return result
  }

  const func = method && Object.keys(method)[0]

  if (method && typeof method === 'object') {
    if (!func) return pushValue(method)
    if (!engine.methods[func]) {
      // Check if this is supposed to be "data" rather than a function.
      if (engine.isData(method, func)) return pushValue(method, true)
      throw new Error(`Method '${func}' was not found in the Logic Engine.`)
    }

    if (
      !buildState.engine.disableInline &&
      engine.methods[func] &&
      isDeterministic$1(method, engine, buildState)
    ) {
      if (isDeepSync(method, engine)) {
        return pushValue((engine.fallback || engine).run(method), true)
      } else if (!buildState.avoidInlineAsync) {
        processing.push(engine.run(method).then((i) => pushValue(i)))
        return `__%%%${processing.length - 1}%%%__`
      } else {
        buildState.asyncDetected = true
        return `(await ${pushValue(engine.run(method))})`
      }
    }

    let lower = method[func]
    if (!lower || typeof lower !== 'object') lower = [lower]

    if (engine.methods[func] && engine.methods[func].compile) {
      let str = engine.methods[func].compile(lower, buildState)
      if (str[Compiled]) str = str[Compiled]

      if ((str || '').startsWith('await')) buildState.asyncDetected = true

      if (str !== false) return str
    }

    let coerce = engine.methods[func].optimizeUnary ? '' : 'coerceArray'
    if (!coerce && Array.isArray(lower) && lower.length === 1) lower = lower[0]
    else if (coerce && Array.isArray(lower)) coerce = ''

    const argumentsDict = [', context', ', context, above', ', context, above, engine']

    if (typeof engine.methods[func] === 'function') {
      asyncDetected = !isSync(engine.methods[func])
      const argumentsNeeded = argumentsDict[countArguments(engine.methods[func]) - 1] || argumentsDict[2]
      return makeAsync(`engine.methods["${func}"](${coerce}(` + buildString(lower, buildState) + ')' + argumentsNeeded + ')')
    } else {
      asyncDetected = Boolean(async && engine.methods[func] && engine.methods[func].asyncMethod)
      const argCount = countArguments(asyncDetected ? engine.methods[func].asyncMethod : engine.methods[func].method)
      const argumentsNeeded = argumentsDict[argCount - 1] || argumentsDict[2]

      if (engine.methods[func] && (typeof engine.methods[func].traverse === 'undefined' ? true : engine.methods[func].traverse)) {
        return makeAsync(`engine.methods["${func}"]${asyncDetected ? '.asyncMethod' : '.method'}(${coerce}(` + buildString(lower, buildState) + ')' + argumentsNeeded + ')')
      } else {
        notTraversed.push(lower)
        return makeAsync(`engine.methods["${func}"]${asyncDetected ? '.asyncMethod' : '.method'}(` + `notTraversed[${notTraversed.length - 1}]` + argumentsNeeded + ')')
      }
    }
  }
  return pushValue(method)
}

/**
 * Synchronously compiles the logic to a function that can run the logic more optimally.
 * @param {*} method
 * @param {BuildState} [buildState]
 * @returns
 */
function build (method, buildState = {}) {
  Object.assign(
    buildState,
    Object.assign(
      {
        notTraversed: [],
        methods: [],
        state: {},
        processing: [],
        async: buildState.engine.async,
        asyncDetected: false,
        values: [],
        compile: compileTemplate
      },
      buildState
    )
  )
  const str = buildString(method, buildState)
  return processBuiltString(method, str, buildState)
}

/**
 * Asynchronously compiles the logic to a function that can run the logic more optimally. Also supports async logic methods.
 * @param {*} method
 * @param {BuildState} [buildState]
 * @returns
 */
async function buildAsync (method, buildState = {}) {
  Object.assign(
    buildState,
    Object.assign(
      {
        notTraversed: [],
        methods: [],
        state: {},
        processing: [],
        async: buildState.engine.async,
        asyncDetected: false,
        values: [],
        compile: compileTemplate
      },
      buildState
    )
  )
  const str = buildString(method, buildState)
  buildState.processing = await Promise.all(buildState.processing || [])
  return processBuiltString(method, str, buildState)
}

/**
 * Takes the string that's been generated and does some post-processing on it to be evaluated.
 * @param {*} method
 * @param {*} str
 * @param {BuildState} buildState
 * @returns
 */
function processBuiltString (method, str, buildState) {
  const {
    engine,
    methods,
    notTraversed,
    processing = [],
    values
  } = buildState

  const above = []

  processing.forEach((item, x) => {
    str = str.replace(`__%%%${x}%%%__`, item)
  })

  const final = `(values, methods, notTraversed, asyncIterators, engine, above, coerceArray) => ${buildState.asyncDetected ? 'async' : ''} (context ${buildState.extraArguments ? ',' + buildState.extraArguments : ''}) => { const result = ${str}; return result }`
  // console.log(str)
  // console.log(final)
  // eslint-disable-next-line no-eval
  return Object.assign(
    (typeof globalThis !== 'undefined' ? globalThis : global).eval(final)(values, methods, notTraversed, asyncIterators, engine, above, coerceArray), {
      [Sync]: !buildState.asyncDetected,
      aboveDetected: typeof str === 'string' && str.includes(', above')
    })
}

const Compiler = {
  build,
  buildAsync,
  buildString
}

// @ts-check
/**
 * Checks if optional chaining is supported for the compiler
 * @returns {Boolean}
 */
const getIsOptionalChainingSupported = () => {
  try {
    // eslint-disable-next-line no-unused-vars
    const test = {}
    // eslint-disable-next-line no-eval
    const isUndefined = (typeof globalThis !== 'undefined' ? globalThis : global).eval('(test) => test?.foo?.bar')(test)
    return isUndefined === undefined
  } catch (err) {
    return false
  }
}
const chainingSupported = getIsOptionalChainingSupported()

// @ts-check
class InvalidControlInput extends Error {
  constructor (input) {
    super()
    this.message =
      'Built-in control structures are not allowed to receive dynamic inputs, this could allow a lesser version of remote-code execution.'
    this.input = input
  }
}

const parsedPaths = new Map()

/**
 * Splits a path string into an array of parts; lightly memoized.
 * It will reset the entire cache after 2048 paths, this could be improved
 * by implementing an LRU cache or something, but I'm trying to keep
 * this library fairly dep free, and the code not too cumbersome.
 *
 * Memoizing the splitPath function can be seen as cheating, but I think it's likely
 * that a lot of the same paths will be used for logic, so it's a good optimization.
 *
 * @param {string} str
 * @returns {string[]}
 */
function splitPathMemoized (str) {
  if (parsedPaths.has(str)) return parsedPaths.get(str)
  if (parsedPaths.size > 2048) parsedPaths.clear()
  const parts = splitPath(str)
  parsedPaths.set(str, parts)
  return parts
}

/**
 * Splits a path string into an array of parts.
 *
 * @example splitPath('a.b.c') // ['a', 'b', 'c']
 * @example splitPath('a\\.b.c') // ['a.b', 'c']
 * @example splitPath('a\\\\.b.c') // ['a\\', 'b', 'c']
 * @example splitPath('a\\\\\\.b.c') // ['a\\.b', 'c']
 * @example splitPath('hello') // ['hello']
 * @example splitPath('hello\\') // ['hello\\']
 * @example splitPath('hello\\\\') // ['hello\\']
 *
 * @param {string} str
 * @param {string} separator
 * @returns {string[]}
 */
function splitPath (str, separator = '.', escape = '\\', up = '/') {
  const parts = []
  let current = ''

  for (let i = 0; i < str.length; i++) {
    const char = str[i]
    if (char === escape) {
      if (str[i + 1] === separator || str[i + 1] === up) {
        current += str[i + 1]
        i++
      } else if (str[i + 1] === escape) {
        current += escape
        i++
        // The following else might be something tweaked in a spec.
      } else current += escape
    } else if (char === separator) {
      parts.push(current)
      current = ''
    } else current += char
  }

  // The if prevents me from pushing more sections than characters
  // This is so that "." will [''] and not ['','']
  // But .h will be ['','.h']
  // .. becomes ['',''], ..h becomes ['', '', 'h']
  if (parts.length !== str.length) parts.push(current)
  return parts
}

// @ts-check

function isDeterministic (method, engine, buildState) {
  if (Array.isArray(method)) {
    return method.every((i) => isDeterministic(i, engine, buildState))
  }
  if (method && typeof method === 'object') {
    const func = Object.keys(method)[0]
    const lower = method[func]

    if (engine.isData(method, func)) return true
    if (!engine.methods[func]) throw new Error(`Method '${func}' was not found in the Logic Engine.`)

    if (engine.methods[func].traverse === false) {
      return typeof engine.methods[func].deterministic === 'function'
        ? engine.methods[func].deterministic(lower, buildState)
        : engine.methods[func].deterministic
    }
    return typeof engine.methods[func].deterministic === 'function'
      ? engine.methods[func].deterministic(lower, buildState)
      : engine.methods[func].deterministic &&
          isDeterministic(lower, engine, buildState)
  }
  return true
}

function isSyncDeep (method, engine, buildState) {
  if (Array.isArray(method)) {
    return method.every((i) => isSyncDeep(i, engine, buildState))
  }

  if (method && typeof method === 'object') {
    const func = Object.keys(method)[0]
    const lower = method[func]
    if (engine.isData(method, func)) return true
    if (!engine.methods[func]) throw new Error(`Method '${func}' was not found in the Logic Engine.`)
    if (engine.methods[func].traverse === false) return typeof engine.methods[func][Sync] === 'function' ? engine.methods[func][Sync](lower, buildState) : engine.methods[func][Sync]
    return typeof engine.methods[func][Sync] === 'function' ? engine.methods[func][Sync](lower, buildState) : engine.methods[func][Sync] && isSyncDeep(lower, engine, buildState)
  }

  return true
}

const defaultMethods = {
  '+': (data) => {
    if (typeof data === 'string') return +data
    if (typeof data === 'number') return +data
    let res = 0
    for (let i = 0; i < data.length; i++) res += +data[i]
    return res
  },
  '*': (data) => {
    let res = 1
    for (let i = 0; i < data.length; i++) res *= +data[i]
    return res
  },
  '/': (data) => {
    let res = data[0]
    for (let i = 1; i < data.length; i++) res /= +data[i]
    return res
  },
  '-': (data) => {
    if (typeof data === 'string') return -data
    if (typeof data === 'number') return -data
    if (data.length === 1) return -data[0]
    let res = data[0]
    for (let i = 1; i < data.length; i++) res -= +data[i]
    return res
  },
  '%': (data) => {
    let res = data[0]
    for (let i = 1; i < data.length; i++) res %= +data[i]
    return res
  },
  max: (data) => Math.max(...data),
  min: (data) => Math.min(...data),
  in: ([item, array]) => (array || []).includes(item),
  '>': ([a, b]) => a > b,
  '<': ([a, b, c]) => (c === undefined ? a < b : a < b && b < c),
  preserve: {
    traverse: false,
    method: declareSync((i) => i, true),
    [Sync]: () => true
  },
  if: {
    method: (input, context, above, engine) => {
      if (!Array.isArray(input)) throw new InvalidControlInput(input)

      if (input.length === 1) return engine.run(input[0], context, { above })
      if (input.length < 2) return null

      input = [...input]
      if (input.length % 2 !== 1) input.push(null)

      // fallback to the default if the condition is false
      const onFalse = input.pop()

      // while there are still conditions
      while (input.length) {
        const check = input.shift()
        const onTrue = input.shift()

        const test = engine.run(check, context, { above })

        // if the condition is true, run the true branch
        if (engine.truthy(test)) return engine.run(onTrue, context, { above })
      }

      return engine.run(onFalse, context, { above })
    },
    [Sync]: (data, buildState) => isSyncDeep(data, buildState.engine, buildState),
    deterministic: (data, buildState) => {
      return isDeterministic(data, buildState.engine, buildState)
    },
    asyncMethod: async (input, context, above, engine) => {
      if (!Array.isArray(input)) throw new InvalidControlInput(input)

      // check the bounds
      if (input.length === 1) return engine.run(input[0], context, { above })
      if (input.length < 2) return null

      input = [...input]

      if (input.length % 2 !== 1) input.push(null)

      // fallback to the default if the condition is false
      const onFalse = input.pop()

      // while there are still conditions
      while (input.length) {
        const check = input.shift()
        const onTrue = input.shift()

        const test = await engine.run(check, context, { above })

        // if the condition is true, run the true branch
        if (engine.truthy(test)) return engine.run(onTrue, context, { above })
      }

      return engine.run(onFalse, context, { above })
    },
    traverse: false
  },
  '<=': ([a, b, c]) => (c === undefined ? a <= b : a <= b && b <= c),
  '>=': ([a, b]) => a >= b,
  // eslint-disable-next-line eqeqeq
  '==': ([a, b]) => a == b,
  '===': ([a, b]) => a === b,
  // eslint-disable-next-line eqeqeq
  '!=': ([a, b]) => a != b,
  '!==': ([a, b]) => a !== b,
  xor: ([a, b]) => a ^ b,
  // Why "executeInLoop"? Because if it needs to execute to get an array, I do not want to execute the arguments,
  // Both for performance and safety reasons.
  or: {
    method: (arr, _1, _2, engine) => {
      // See "executeInLoop" above
      const executeInLoop = Array.isArray(arr)
      if (!executeInLoop) arr = engine.run(arr, _1, { above: _2 })

      let item
      for (let i = 0; i < arr.length; i++) {
        item = executeInLoop ? engine.run(arr[i], _1, { above: _2 }) : arr[i]
        if (engine.truthy(item)) return item
      }

      return item
    },
    asyncMethod: async (arr, _1, _2, engine) => {
      // See "executeInLoop" above
      const executeInLoop = Array.isArray(arr)
      if (!executeInLoop) arr = await engine.run(arr, _1, { above: _2 })

      let item
      for (let i = 0; i < arr.length; i++) {
        item = executeInLoop ? await engine.run(arr[i], _1, { above: _2 }) : arr[i]
        if (engine.truthy(item)) return item
      }

      return item
    },
    deterministic: (data, buildState) => isDeterministic(data, buildState.engine, buildState),
    compile: (data, buildState) => {
      if (!buildState.engine.truthy.IDENTITY) return false
      if (Array.isArray(data)) {
        return `(${data.map((i) => buildString(i, buildState)).join(' || ')})`
      } else {
        return `(${buildString(data, buildState)}).reduce((a,b) => a||b, false)`
      }
    },
    traverse: false
  },
  and: {
    method: (arr, _1, _2, engine) => {
      // See "executeInLoop" above
      const executeInLoop = Array.isArray(arr)
      if (!executeInLoop) arr = engine.run(arr, _1, { above: _2 })

      let item
      for (let i = 0; i < arr.length; i++) {
        item = executeInLoop ? engine.run(arr[i], _1, { above: _2 }) : arr[i]
        if (!engine.truthy(item)) return item
      }
      return item
    },
    asyncMethod: async (arr, _1, _2, engine) => {
      // See "executeInLoop" above
      const executeInLoop = Array.isArray(arr)
      if (!executeInLoop) arr = await engine.run(arr, _1, { above: _2 })

      let item
      for (let i = 0; i < arr.length; i++) {
        item = executeInLoop ? await engine.run(arr[i], _1, { above: _2 }) : arr[i]
        if (!engine.truthy(item)) return item
      }
      return item
    },
    traverse: false,
    deterministic: (data, buildState) => isDeterministic(data, buildState.engine, buildState),
    compile: (data, buildState) => {
      if (!buildState.engine.truthy.IDENTITY) return false
      if (Array.isArray(data)) {
        return `(${data.map((i) => buildString(i, buildState)).join(' && ')})`
      } else {
        return `(${buildString(data, buildState)}).reduce((a,b) => a&&b, true)`
      }
    }
  },
  substr: ([string, from, end]) => {
    if (end < 0) {
      const result = string.substr(from)
      return result.substr(0, result.length + end)
    }
    return string.substr(from, end)
  },
  length: ([i]) => {
    if (typeof i === 'string' || Array.isArray(i)) return i.length
    if (i && typeof i === 'object') return Object.keys(i).length
    return 0
  },
  get: {
    method: ([data, key, defaultValue], context, above, engine) => {
      const notFound = defaultValue === undefined ? null : defaultValue

      const subProps = splitPathMemoized(String(key))
      for (let i = 0; i < subProps.length; i++) {
        if (data === null || data === undefined) {
          return notFound
        }
        // Descending into context
        data = data[subProps[i]]
        if (data === undefined) {
          return notFound
        }
      }
      if (engine.allowFunctions || typeof data[key] !== 'function') {
        return data
      }
    }
  },
  var: (key, context, above, engine) => {
    let b
    if (Array.isArray(key)) {
      b = key[1]
      key = key[0]
    }
    let iter = 0
    while (
      typeof key === 'string' &&
      key.startsWith('../') &&
      iter < above.length
    ) {
      context = above[iter++]
      key = key.substring(3)
      // A performance optimization that allows you to pass the previous above array without spreading it as the last argument
      if (iter === above.length && Array.isArray(context)) {
        iter = 0
        above = context
        context = above[iter++]
      }
    }

    const notFound = b === undefined ? null : b
    if (typeof key === 'undefined' || key === '' || key === null) {
      if (engine.allowFunctions || typeof context !== 'function') {
        return context
      }
      return null
    }
    const subProps = splitPathMemoized(String(key))
    for (let i = 0; i < subProps.length; i++) {
      if (context === null || context === undefined) {
        return notFound
      }
      // Descending into context
      context = context[subProps[i]]
      if (context === undefined) {
        return notFound
      }
    }
    if (engine.allowFunctions || typeof context !== 'function') {
      return context
    }
    return null
  },
  missing: (checked, context, above, engine) => {
    return (Array.isArray(checked) ? checked : [checked]).filter((key) => {
      return defaultMethods.var(key, context, above, engine) === null
    })
  },
  missing_some: ([needCount, options], context, above, engine) => {
    const missing = defaultMethods.missing(options, context, above, engine)
    if (options.length - missing.length >= needCount) {
      return []
    } else {
      return missing
    }
  },
  map: createArrayIterativeMethod('map'),
  some: createArrayIterativeMethod('some', true),
  all: createArrayIterativeMethod('every', true),
  none: {
    traverse: false,
    // todo: add async build & build
    method: (val, context, above, engine) => {
      return !defaultMethods.some.method(val, context, above, engine)
    },
    asyncMethod: async (val, context, above, engine) => {
      return !(await defaultMethods.some.asyncMethod(
        val,
        context,
        above,
        engine
      ))
    },
    compile: (data, buildState) => {
      const result = defaultMethods.some.compile(data, buildState)
      return result ? buildState.compile`!(${result})` : false
    }
  },
  merge: (arrays) => (Array.isArray(arrays) ? [].concat(...arrays) : [arrays]),
  every: createArrayIterativeMethod('every'),
  filter: createArrayIterativeMethod('filter'),
  reduce: {
    deterministic: (data, buildState) => {
      return (
        isDeterministic(data[0], buildState.engine, buildState) &&
        isDeterministic(data[1], buildState.engine, {
          ...buildState,
          insideIterator: true
        })
      )
    },
    compile: (data, buildState) => {
      if (!Array.isArray(data)) throw new InvalidControlInput(data)
      const { async } = buildState
      let [selector, mapper, defaultValue] = data
      selector = buildString(selector, buildState)
      if (typeof defaultValue !== 'undefined') {
        defaultValue = buildString(defaultValue, buildState)
      }
      const mapState = {
        ...buildState,
        extraArguments: 'above',
        avoidInlineAsync: true
      }
      mapper = build(mapper, mapState)
      const aboveArray = mapper.aboveDetected ? '[null, context, above]' : 'null'

      buildState.methods.push(mapper)
      if (async) {
        if (!isSync(mapper) || selector.includes('await')) {
          buildState.detectAsync = true
          if (typeof defaultValue !== 'undefined') {
            return `await asyncIterators.reduce(${selector} || [], (a,b) => methods[${
              buildState.methods.length - 1
            }]({ accumulator: a, current: b }, ${aboveArray}), ${defaultValue})`
          }
          return `await asyncIterators.reduce(${selector} || [], (a,b) => methods[${
            buildState.methods.length - 1
          }]({ accumulator: a, current: b }, ${aboveArray}))`
        }
      }
      if (typeof defaultValue !== 'undefined') {
        return `(${selector} || []).reduce((a,b) => methods[${
          buildState.methods.length - 1
        }]({ accumulator: a, current: b }, ${aboveArray}), ${defaultValue})`
      }
      return `(${selector} || []).reduce((a,b) => methods[${
        buildState.methods.length - 1
      }]({ accumulator: a, current: b }, ${aboveArray}))`
    },
    method: (input, context, above, engine) => {
      if (!Array.isArray(input)) throw new InvalidControlInput(input)
      let [selector, mapper, defaultValue] = input
      defaultValue = engine.run(defaultValue, context, {
        above
      })
      selector =
        engine.run(selector, context, {
          above
        }) || []
      const func = (accumulator, current) => {
        return engine.run(
          mapper,
          {
            accumulator,
            current
          },
          {
            above: [selector, context, above]
          }
        )
      }
      if (typeof defaultValue === 'undefined') {
        return selector.reduce(func)
      }
      return selector.reduce(func, defaultValue)
    },
    [Sync]: (data, buildState) => isSyncDeep(data, buildState.engine, buildState),
    asyncMethod: async (input, context, above, engine) => {
      if (!Array.isArray(input)) throw new InvalidControlInput(input)
      let [selector, mapper, defaultValue] = input
      defaultValue = await engine.run(defaultValue, context, {
        above
      })
      selector =
        (await engine.run(selector, context, {
          above
        })) || []
      return asyncIterators.reduce(
        selector,
        (accumulator, current) => {
          return engine.run(
            mapper,
            {
              accumulator,
              current
            },
            {
              above: [selector, context, above]
            }
          )
        },
        defaultValue
      )
    },
    traverse: false
  },
  '!': (value, _1, _2, engine) => Array.isArray(value) ? !engine.truthy(value[0]) : !engine.truthy(value),
  '!!': (value, _1, _2, engine) => Boolean(Array.isArray(value) ? engine.truthy(value[0]) : engine.truthy(value)),
  cat: (arr) => {
    if (typeof arr === 'string') return arr
    let res = ''
    for (let i = 0; i < arr.length; i++) res += arr[i]
    return res
  },
  keys: ([obj]) => typeof obj === 'object' ? Object.keys(obj) : [],
  pipe: {
    traverse: false,
    [Sync]: (data, buildState) => isSyncDeep(data, buildState.engine, buildState),
    method: (args, context, above, engine) => {
      if (!Array.isArray(args)) throw new Error('Data for pipe must be an array')
      let answer = engine.run(args[0], context, { above: [args, context, above] })
      for (let i = 1; i < args.length; i++) answer = engine.run(args[i], answer, { above: [args, context, above] })
      return answer
    },
    asyncMethod: async (args, context, above, engine) => {
      if (!Array.isArray(args)) throw new Error('Data for pipe must be an array')
      let answer = await engine.run(args[0], context, { above: [args, context, above] })
      for (let i = 1; i < args.length; i++) answer = await engine.run(args[i], answer, { above: [args, context, above] })
      return answer
    },
    compile: (args, buildState) => {
      let res = buildState.compile`${args[0]}`
      for (let i = 1; i < args.length; i++) res = buildState.compile`${build(args[i], { ...buildState, extraArguments: 'above' })}(${res}, [null, context, above])`
      return res
    },
    deterministic: (data, buildState) => {
      if (!Array.isArray(data)) return false
      data = [...data]
      const first = data.shift()
      return isDeterministic(first, buildState.engine, buildState) && isDeterministic(data, buildState.engine, { ...buildState, insideIterator: true })
    }
  },
  eachKey: {
    traverse: false,
    [Sync]: (data, buildState) => isSyncDeep(Object.values(data[Object.keys(data)[0]]), buildState.engine, buildState),
    method: (object, context, above, engine) => {
      const result = Object.keys(object).reduce((accumulator, key) => {
        const item = object[key]
        Object.defineProperty(accumulator, key, {
          enumerable: true,
          value: engine.run(item, context, { above })
        })
        return accumulator
      }, {})
      return result
    },
    deterministic: (data, buildState) => {
      if (data && typeof data === 'object') {
        return Object.values(data).every((i) => {
          return isDeterministic(i, buildState.engine, buildState)
        })
      }
      throw new InvalidControlInput(data)
    },
    compile: (data, buildState) => {
      // what's nice about this is that I don't have to worry about whether it's async or not, the lower entries take care of that ;)
      // however, this is not engineered support yields, I will have to make a note of that & possibly support it at a later point.
      if (data && typeof data === 'object') {
        const result = `({ ${Object.keys(data)
          .reduce((accumulator, key) => {
            accumulator.push(
              // @ts-ignore Never[] is not accurate
              `${JSON.stringify(key)}: ${buildString(data[key], buildState)}`
            )
            return accumulator
          }, [])
          .join(',')} })`
        return result
      }
      throw new InvalidControlInput(data)
    },
    asyncMethod: async (object, context, above, engine) => {
      const result = await asyncIterators.reduce(
        Object.keys(object),
        async (accumulator, key) => {
          const item = object[key]
          Object.defineProperty(accumulator, key, {
            enumerable: true,
            value: await engine.run(item, context, { above })
          })
          return accumulator
        },
        {}
      )
      return result
    }
  }
}

function createArrayIterativeMethod (name, useTruthy = false) {
  return {
    deterministic: (data, buildState) => {
      return (
        isDeterministic(data[0], buildState.engine, buildState) &&
        isDeterministic(data[1], buildState.engine, {
          ...buildState,
          insideIterator: true
        })
      )
    },
    [Sync]: (data, buildState) => isSyncDeep(data, buildState.engine, buildState),
    method: (input, context, above, engine) => {
      if (!Array.isArray(input)) throw new InvalidControlInput(input)
      let [selector, mapper] = input
      selector =
        engine.run(selector, context, {
          above
        }) || []

      return selector[name]((i, index) => {
        const result = engine.run(mapper, i, {
          above: [{ iterator: selector, index }, context, above]
        })
        return useTruthy ? engine.truthy(result) : result
      })
    },
    asyncMethod: async (input, context, above, engine) => {
      if (!Array.isArray(input)) throw new InvalidControlInput(input)
      let [selector, mapper] = input
      selector =
        (await engine.run(selector, context, {
          above
        })) || []
      return asyncIterators[name](selector, (i, index) => {
        const result = engine.run(mapper, i, {
          above: [{ iterator: selector, index }, context, above]
        })
        return useTruthy ? engine.truthy(result) : result
      })
    },
    compile: (data, buildState) => {
      if (!Array.isArray(data)) throw new InvalidControlInput(data)
      const { async } = buildState
      const [selector, mapper] = data

      const mapState = {
        ...buildState,
        avoidInlineAsync: true,
        iteratorCompile: true,
        extraArguments: 'index, above'
      }

      const method = build(mapper, mapState)
      const aboveArray = method.aboveDetected ? buildState.compile`[{ iterator: z, index: x }, context, above]` : buildState.compile`null`

      if (async) {
        if (!isSyncDeep(mapper, buildState.engine, buildState)) {
          buildState.detectAsync = true
          return buildState.compile`await asyncIterators[${name}](${selector} || [], async (i, x, z) => ${method}(i, x, ${aboveArray}))`
        }
      }

      return buildState.compile`(${selector} || [])[${name}]((i, x, z) => ${method}(i, x, ${aboveArray}))`
    },
    traverse: false
  }
}
defaultMethods['?:'] = defaultMethods.if
// declare all of the functions here synchronous
Object.keys(defaultMethods).forEach((item) => {
  if (typeof defaultMethods[item] === 'function') {
    defaultMethods[item][Sync] = true
  }
  defaultMethods[item].deterministic =
    typeof defaultMethods[item].deterministic === 'undefined'
      ? true
      : defaultMethods[item].deterministic
})
// @ts-ignore Allow custom attribute
defaultMethods.var.deterministic = (data, buildState) => {
  return buildState.insideIterator && !String(data).includes('../../')
}
Object.assign(defaultMethods.missing, {
  deterministic: false
})
Object.assign(defaultMethods.missing_some, {
  deterministic: false
})
// @ts-ignore Allow custom attribute
defaultMethods['<'].compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  if (data.length === 2) return buildState.compile`(${data[0]} < ${data[1]})`
  if (data.length === 3) return buildState.compile`(${data[0]} < ${data[1]} && ${data[1]} < ${data[2]})`
  return false
}
// @ts-ignore Allow custom attribute
defaultMethods['<='].compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  if (data.length === 2) return buildState.compile`(${data[0]} <= ${data[1]})`
  if (data.length === 3) return buildState.compile`(${data[0]} <= ${data[1]} && ${data[1]} <= ${data[2]})`
  return false
}
// @ts-ignore Allow custom attribute
defaultMethods.min.compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  return `Math.min(${data
    .map((i) => buildString(i, buildState))
    .join(', ')})`
}
// @ts-ignore Allow custom attribute
defaultMethods.max.compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  return `Math.max(${data
    .map((i) => buildString(i, buildState))
    .join(', ')})`
}
// @ts-ignore Allow custom attribute
defaultMethods['>'].compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  if (data.length !== 2) return false
  return buildState.compile`(${data[0]} > ${data[1]})`
}
// @ts-ignore Allow custom attribute
defaultMethods['>='].compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  if (data.length !== 2) return false
  return buildState.compile`(${data[0]} >= ${data[1]})`
}
// @ts-ignore Allow custom attribute
defaultMethods['=='].compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  if (data.length !== 2) return false
  return buildState.compile`(${data[0]} == ${data[1]})`
}
// @ts-ignore Allow custom attribute
defaultMethods['!='].compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  if (data.length !== 2) return false
  return buildState.compile`(${data[0]} != ${data[1]})`
}
// @ts-ignore Allow custom attribute
defaultMethods.if.compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  if (data.length < 3) return false

  data = [...data]
  if (data.length % 2 !== 1) data.push(null)
  const onFalse = data.pop()

  let res = buildState.compile``
  while (data.length) {
    const condition = data.shift()
    const onTrue = data.shift()
    res = buildState.compile`${res} engine.truthy(${condition}) ? ${onTrue} : `
  }

  return buildState.compile`(${res} ${onFalse})`
}
// @ts-ignore Allow custom attribute
defaultMethods['==='].compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  if (data.length !== 2) return false
  return buildState.compile`(${data[0]} === ${data[1]})`
}
// @ts-ignore Allow custom attribute
defaultMethods['+'].compile = function (data, buildState) {
  if (Array.isArray(data)) {
    return `(${data
      .map((i) => `(+${buildString(i, buildState)})`)
      .join(' + ')})`
  } else if (typeof data === 'string' || typeof data === 'number') {
    return `(+${buildString(data, buildState)})`
  } else {
    return `([].concat(${buildString(
      data,
      buildState
    )})).reduce((a,b) => (+a)+(+b), 0)`
  }
}

// @ts-ignore Allow custom attribute
defaultMethods['%'].compile = function (data, buildState) {
  if (Array.isArray(data)) {
    return `(${data
      .map((i) => `(+${buildString(i, buildState)})`)
      .join(' % ')})`
  } else {
    return `(${buildString(data, buildState)}).reduce((a,b) => (+a)%(+b))`
  }
}

// @ts-ignore Allow custom attribute
defaultMethods.in.compile = function (data, buildState) {
  if (!Array.isArray(data)) return false
  return buildState.compile`(${data[1]} || []).includes(${data[0]})`
}

// @ts-ignore Allow custom attribute
defaultMethods['-'].compile = function (data, buildState) {
  if (Array.isArray(data)) {
    return `${data.length === 1 ? '-' : ''}(${data
      .map((i) => `(+${buildString(i, buildState)})`)
      .join(' - ')})`
  }
  if (typeof data === 'string' || typeof data === 'number') {
    return `(-${buildString(data, buildState)})`
  } else {
    return `((a=>(a.length===1?a[0]=-a[0]:a)&0||a)([].concat(${buildString(
      data,
      buildState
    )}))).reduce((a,b) => (+a)-(+b))`
  }
}
// @ts-ignore Allow custom attribute
defaultMethods['/'].compile = function (data, buildState) {
  if (Array.isArray(data)) {
    return `(${data
      .map((i) => `(+${buildString(i, buildState)})`)
      .join(' / ')})`
  } else {
    return `(${buildString(data, buildState)}).reduce((a,b) => (+a)/(+b))`
  }
}
// @ts-ignore Allow custom attribute
defaultMethods['*'].compile = function (data, buildState) {
  if (Array.isArray(data)) {
    return `(${data
      .map((i) => `(+${buildString(i, buildState)})`)
      .join(' * ')})`
  } else {
    return `(${buildString(data, buildState)}).reduce((a,b) => (+a)*(+b))`
  }
}
// @ts-ignore Allow custom attribute
defaultMethods.cat.compile = function (data, buildState) {
  if (typeof data === 'string') return JSON.stringify(data)
  if (!Array.isArray(data)) return false
  let res = buildState.compile`''`
  for (let i = 0; i < data.length; i++) res = buildState.compile`${res} + ${data[i]}`
  return buildState.compile`(${res})`
}

// @ts-ignore Allow custom attribute
defaultMethods['!'].compile = function (
  data,
  buildState
) {
  if (Array.isArray(data)) return buildState.compile`(!engine.truthy(${data[0]}))`
  return buildState.compile`(!engine.truthy(${data}))`
}

defaultMethods.not = defaultMethods['!']

// @ts-ignore Allow custom attribute
defaultMethods['!!'].compile = function (data, buildState) {
  if (Array.isArray(data)) return buildState.compile`(!!engine.truthy(${data[0]}))`
  return `(!!engine.truthy(${data}))`
}
defaultMethods.none.deterministic = defaultMethods.some.deterministic
defaultMethods.get.compile = function (data, buildState) {
  let defaultValue = null
  let key = data
  let obj = null
  if (Array.isArray(data) && data.length <= 3) {
    obj = data[0]
    key = data[1]
    defaultValue = typeof data[2] === 'undefined' ? null : data[2]

    // Bail out if the key is dynamic; dynamic keys are not really optimized by this block.
    if (key && typeof key === 'object') return false

    key = key.toString()
    const pieces = splitPathMemoized(key)
    if (!chainingSupported) {
      return `(((a,b) => (typeof a === 'undefined' || a === null) ? b : a)(${pieces.reduce(
        (text, i) => {
          return `(${text}||0)[${JSON.stringify(i)}]`
        },
        `(${buildString(obj, buildState)}||0)`
      )}, ${buildString(defaultValue, buildState)}))`
    }
    return `((${buildString(obj, buildState)})${pieces
      .map((i) => `?.[${buildString(i, buildState)}]`)
      .join('')} ?? ${buildString(defaultValue, buildState)})`
  }
  return false
}
// @ts-ignore Allow custom attribute
defaultMethods.var.compile = function (data, buildState) {
  let key = data
  let defaultValue = null
  buildState.varTop = buildState.varTop || new Set()
  if (
    !key ||
    typeof data === 'string' ||
    typeof data === 'number' ||
    (Array.isArray(data) && data.length <= 2)
  ) {
    if (Array.isArray(data)) {
      key = data[0]
      defaultValue = typeof data[1] === 'undefined' ? null : data[1]
    }

    if (key === '../index' && buildState.iteratorCompile) return 'index'

    // this counts the number of var accesses to determine if they're all just using this override.
    // this allows for a small optimization :)
    if (typeof key === 'undefined' || key === null || key === '') return 'context'
    if (typeof key !== 'string' && typeof key !== 'number') return false

    key = key.toString()
    if (key.includes('../')) return false

    const pieces = splitPathMemoized(key)
    const [top] = pieces
    buildState.varTop.add(top)

    if (!buildState.engine.allowFunctions) buildState.methods.preventFunctions = a => typeof a === 'function' ? null : a
    else buildState.methods.preventFunctions = a => a

    // support older versions of node
    if (!chainingSupported) {
      return `(methods.preventFunctions(((a,b) => (typeof a === 'undefined' || a === null) ? b : a)(${pieces.reduce(
        (text, i) => `(${text}||0)[${JSON.stringify(i)}]`,
        '(context||0)'
      )}, ${buildString(defaultValue, buildState)})))`
    }
    return `(methods.preventFunctions(context${pieces
      .map((i) => `?.[${JSON.stringify(i)}]`)
      .join('')} ?? ${buildString(defaultValue, buildState)}))`
  }
  return false
}

// @ts-ignore Allowing a optimizeUnary attribute that can be used for performance optimizations
defaultMethods['+'].optimizeUnary = defaultMethods['-'].optimizeUnary = defaultMethods.var.optimizeUnary = defaultMethods['!'].optimizeUnary = defaultMethods['!!'].optimizeUnary = defaultMethods.cat.optimizeUnary = true

const defaultMethods$1 = {
  ...defaultMethods
}

// @ts-check
const omitUndefined = function omitUndefined (obj) {
  Object.keys(obj).forEach((key) => {
    if (obj[key] === undefined) {
      delete obj[key]
    }
  })
  return obj
}

// This is the synchronous version of the optimizer; which the Async one should be based on.

/**
 * Turns an expression like { '+': [1, 2] } into a function that can be called with data.
 * @param {*} logic
 * @param {*} engine
 * @param {string} methodName
 * @param {any[]} above
 * @returns A method that can be called to execute the logic.
 */
function getMethod$1 (logic, engine, methodName, above) {
  const method = engine.methods[methodName]
  const called = method.method ? method.method : method

  if (method.traverse === false) {
    const args = logic[methodName]
    return (data, abv) => called(args, data, abv || above, engine)
  }

  let args = logic[methodName]
  if (!args || typeof args !== 'object') args = [args]

  if (Array.isArray(args)) {
    const optimizedArgs = args.map(l => optimize$1(l, engine, above))
    return (data, abv) => {
      const evaluatedArgs = optimizedArgs.map(l => typeof l === 'function' ? l(data, abv) : l)
      return called(evaluatedArgs, data, abv || above, engine)
    }
  } else {
    const optimizedArgs = optimize$1(args, engine, above)
    return (data, abv) => {
      return called(coerceArray(typeof optimizedArgs === 'function' ? optimizedArgs(data, abv) : optimizedArgs, method.optimizeUnary), data, abv || above, engine)
    }
  }
}

/**
 * Processes the logic for the engine once so that it doesn't need to be traversed again.
 * @param {*} logic
 * @param {*} engine
 * @param {any[]} above
 * @returns A function that optimizes the logic for the engine in advance.
 */
function optimize$1 (logic, engine, above = []) {
  if (Array.isArray(logic)) {
    const arr = logic.map(l => optimize$1(l, engine, above))
    return (data, abv) => arr.map(l => typeof l === 'function' ? l(data, abv) : l)
  }
  if (logic && typeof logic === 'object') {
    const keys = Object.keys(logic)
    const methodName = keys[0]

    const isData = engine.isData(logic, methodName)
    if (isData) return () => logic

    // If we have a deterministic function, we can just return the result of the evaluation,
    // basically inlining the operation.
    const deterministic = !engine.disableInline && isDeterministic$1(logic, engine, { engine })

    if (methodName in engine.methods) {
      const result = getMethod$1(logic, engine, methodName, above)
      if (deterministic) return result()
      return result
    }
  }

  return logic
}

const oldAll = defaultMethods$1.all

const all = {
  method: (args, context, above, engine) => {
    if (Array.isArray(args)) {
      const first = engine.run(args[0], context, above)
      if (Array.isArray(first) && first.length === 0) return false
    }
    return oldAll.method(args, context, above, engine)
  },
  asyncMethod: async (args, context, above, engine) => {
    if (Array.isArray(args)) {
      const first = await engine.run(args[0], context, above)
      if (Array.isArray(first) && first.length === 0) return false
    }
    return oldAll.asyncMethod(args, context, above, engine)
  },
  deterministic: oldAll.deterministic,
  traverse: oldAll.traverse
}

function truthy (value) {
  if (Array.isArray(value) && value.length === 0) return false
  return value
}

function applyPatches (engine) {
  engine.methods.all = all
  engine.truthy = truthy
}

// @ts-check

/**
 * An engine capable of running synchronous JSON Logic.
 */
class LogicEngine {
  /**
   * Creates a new instance of the Logic Engine.
   *
   * "compatible" applies a few patches to make it compatible with the preferences of mainline JSON Logic.
   * The main changes are:
   * - In mainline: "all" will return false if the array is empty; by default, we return true.
   * - In mainline: empty arrays are falsey; in our implementation, they are truthy.
   *
   * @param {Object} methods An object that stores key-value pairs between the names of the commands & the functions they execute.
   * @param {{ disableInline?: Boolean, disableInterpretedOptimization?: Boolean, permissive?: boolean, compatible?: boolean }} options
   */
  constructor (
    methods = defaultMethods$1,
    options = { disableInline: false, disableInterpretedOptimization: false, permissive: false }
  ) {
    this.disableInline = options.disableInline
    this.disableInterpretedOptimization = options.disableInterpretedOptimization
    this.methods = { ...methods }

    this.optimizedMap = new WeakMap()
    this.missesSinceSeen = 0

    if (options.compatible) applyPatches(this)

    /** @type {{ disableInline?: Boolean, disableInterpretedOptimization?: Boolean }} */
    this.options = { disableInline: options.disableInline, disableInterpretedOptimization: options.disableInterpretedOptimization }
    if (!this.isData) {
      if (!options.permissive) this.isData = () => false
      else this.isData = (data, key) => !(key in this.methods)
    }
  }

  /**
   * Determines the truthiness of a value.
   * You can override this method to change the way truthiness is determined.
   * @param {*} value
   * @returns
   */
  truthy (value) {
    return value
  }

  /**
   * An internal method used to parse through the JSON Logic at a lower level.
   * @param {*} logic The logic being executed.
   * @param {*} context The context of the logic being run (input to the function.)
   * @param {*} above The context above (can be used for handlebars-style data traversal.)
   * @returns {{ result: *, func: string }}
   */
  _parse (logic, context, above) {
    const [func] = Object.keys(logic)
    const data = logic[func]

    if (this.isData(logic, func)) return logic

    if (!this.methods[func]) throw new Error(`Method '${func}' was not found in the Logic Engine.`)

    if (typeof this.methods[func] === 'function') {
      const input = (!data || typeof data !== 'object') ? [data] : coerceArray(this.run(data, context, { above }))
      return this.methods[func](input, context, above, this)
    }

    if (typeof this.methods[func] === 'object') {
      const { method, traverse } = this.methods[func]
      const shouldTraverse = typeof traverse === 'undefined' ? true : traverse
      const parsedData = shouldTraverse ? ((!data || typeof data !== 'object') ? [data] : coerceArray(this.run(data, context, { above }))) : data
      return method(parsedData, context, above, this)
    }

    throw new Error(`Method '${func}' is not set up properly.`)
  }

  /**
   *
   * @param {String} name The name of the method being added.
   * @param {((args: any, context: any, above: any[], engine: LogicEngine) => any) |{ traverse?: Boolean, method: (args: any, context: any, above: any[], engine: LogicEngine) => any, deterministic?: Function | Boolean }} method
   * @param {{ deterministic?: Boolean, optimizeUnary?: Boolean }} annotations This is used by the compiler to help determine if it can optimize the function being generated.
   */
  addMethod (name, method, { deterministic, optimizeUnary } = {}) {
    if (typeof method === 'function') method = { method, traverse: true }
    else method = { ...method }
    Object.assign(method, omitUndefined({ deterministic, optimizeUnary }))
    this.methods[name] = declareSync(method)
  }

  /**
   * Adds a batch of functions to the engine
   * @param {String} name
   * @param {Object} obj
   * @param {{ deterministic?: Boolean, async?: Boolean, sync?: Boolean }} annotations Not recommended unless you're sure every function from the module will match these annotations.
   */
  addModule (name, obj, annotations) {
    Object.getOwnPropertyNames(obj).forEach((key) => {
      if (typeof obj[key] === 'function' || typeof obj[key] === 'object') this.addMethod(`${name}${name ? '.' : ''}${key}`, obj[key], annotations)
    })
  }

  /**
   * Runs the logic against the data.
   *
   * NOTE: With interpreted optimizations enabled, it will cache the execution plan for the logic for
   * future invocations; if you plan to modify the logic, you should disable this feature, by passing
   * `disableInterpretedOptimization: true` in the constructor.
   *
   * If it detects that a bunch of dynamic objects are being passed in, and it doesn't see the same object,
   * it will disable the interpreted optimization.
   *
   * @param {*} logic The logic to be executed
   * @param {*} data The data being passed in to the logic to be executed against.
   * @param {{ above?: any }} options Options for the invocation
   * @returns {*}
   */
  run (logic, data = {}, options = {}) {
    const { above = [] } = options

    // OPTIMIZER BLOCK //
    if (this.missesSinceSeen > 500) {
      this.disableInterpretedOptimization = true
      this.missesSinceSeen = 0
    }

    if (!this.disableInterpretedOptimization && typeof logic === 'object' && logic && !this.optimizedMap.has(logic)) {
      this.optimizedMap.set(logic, optimize$1(logic, this, above))
      this.missesSinceSeen++
      return typeof this.optimizedMap.get(logic) === 'function' ? this.optimizedMap.get(logic)(data, above) : this.optimizedMap.get(logic)
    }

    if (!this.disableInterpretedOptimization && logic && typeof logic === 'object' && this.optimizedMap.get(logic)) {
      this.missesSinceSeen = 0
      return typeof this.optimizedMap.get(logic) === 'function' ? this.optimizedMap.get(logic)(data, above) : this.optimizedMap.get(logic)
    }
    // END OPTIMIZER BLOCK //

    if (Array.isArray(logic)) {
      const res = []
      for (let i = 0; i < logic.length; i++) res.push(this.run(logic[i], data, { above }))
      return res
    }

    if (logic && typeof logic === 'object' && Object.keys(logic).length > 0) return this._parse(logic, data, above)

    return logic
  }

  /**
   *
   * @param {*} logic The logic to be built.
   * @param {{ top?: Boolean, above?: any }} options
   * @returns {Function}
   */
  build (logic, options = {}) {
    const { above = [], top = true } = options
    if (top) {
      const constructedFunction = build(logic, { state: {}, engine: this, above })
      if (typeof constructedFunction === 'function' || top === true) return (...args) => typeof constructedFunction === 'function' ? constructedFunction(...args) : constructedFunction
      return constructedFunction
    }
    return logic
  }
}
Object.assign(LogicEngine.prototype.truthy, { IDENTITY: true })

// This is the synchronous version of the optimizer; which the Async one should be based on.

/**
 * Turns an expression like { '+': [1, 2] } into a function that can be called with data.
 * @param {*} logic
 * @param {*} engine
 * @param {string} methodName
 * @param {any[]} above
 * @returns A method that can be called to execute the logic.
 */
function getMethod (logic, engine, methodName, above) {
  const method = engine.methods[methodName]
  const called = method.asyncMethod ? method.asyncMethod : method.method ? method.method : method

  if (method.traverse === false) {
    if (typeof method[Sync] === 'function' && method[Sync](logic, { engine })) {
      const called = method.method ? method.method : method
      return declareSync((data, abv) => called(logic[methodName], data, abv || above, engine.fallback), true)
    }

    const args = logic[methodName]
    return (data, abv) => called(args, data, abv || above, engine)
  }

  let args = logic[methodName]
  if (!args || typeof args !== 'object') args = [args]

  if (Array.isArray(args)) {
    const optimizedArgs = args.map(l => optimize(l, engine, above))

    if (isSync(optimizedArgs) && (method.method || method[Sync])) {
      const called = method.method ? method.method : method
      return declareSync((data, abv) => {
        const evaluatedArgs = optimizedArgs.map(l => typeof l === 'function' ? l(data, abv) : l)
        return called(evaluatedArgs, data, abv || above, engine.fallback)
      }, true)
    }

    return async (data, abv) => {
      const evaluatedArgs = await map(optimizedArgs, l => typeof l === 'function' ? l(data, abv) : l)
      return called(evaluatedArgs, data, abv || above, engine)
    }
  } else {
    const optimizedArgs = optimize(args, engine, above)

    if (isSync(optimizedArgs) && (method.method || method[Sync])) {
      const called = method.method ? method.method : method
      return declareSync((data, abv) => called(coerceArray(typeof optimizedArgs === 'function' ? optimizedArgs(data, abv) : optimizedArgs, method.optimizeUnary), data, abv || above, engine), true)
    }

    return async (data, abv) => {
      return called(coerceArray(typeof optimizedArgs === 'function' ? await optimizedArgs(data, abv) : optimizedArgs, method.optimizeUnary), data, abv || above, engine)
    }
  }
}

/**
 * Processes the logic for the engine once so that it doesn't need to be traversed again.
 * @param {*} logic
 * @param {*} engine
 * @param {any[]} above
 * @returns A function that optimizes the logic for the engine in advance.
 */
function optimize (logic, engine, above = []) {
  engine.fallback.allowFunctions = engine.allowFunctions
  if (Array.isArray(logic)) {
    const arr = logic.map(l => optimize(l, engine, above))
    if (isSync(arr)) return declareSync((data, abv) => arr.map(l => typeof l === 'function' ? l(data, abv) : l), true)
    return async (data, abv) => map(arr, l => typeof l === 'function' ? l(data, abv) : l)
  }
  if (logic && typeof logic === 'object') {
    const keys = Object.keys(logic)
    const methodName = keys[0]

    const isData = engine.isData(logic, methodName)
    if (isData) return () => logic

    // If we have a deterministic function, we can just return the result of the evaluation,
    // basically inlining the operation.
    const deterministic = !engine.disableInline && isDeterministic$1(logic, engine, { engine })

    if (methodName in engine.methods) {
      const result = getMethod(logic, engine, methodName, above)
      if (deterministic) {
        let computed

        if (isSync(result)) {
          return declareSync(() => {
            if (!computed) computed = result()
            return computed
          }, true)
        }

        // For async, it's a little less straightforward since it could be a promise,
        // so we'll make it a closure.
        return async () => {
          if (!computed) computed = await result()
          return computed
        }
      }
      return result
    }
  }

  return logic
}

// @ts-check

/**
 * An engine capable of running asynchronous JSON Logic.
 */
class AsyncLogicEngine {
  /**
   * Creates a new instance of the Logic Engine.
   *
   * "compatible" applies a few patches to make it compatible with the preferences of mainline JSON Logic.
   * The main changes are:
   * - In mainline: "all" will return false if the array is empty; by default, we return true.
   * - In mainline: empty arrays are falsey; in our implementation, they are truthy.
   *
   * @param {Object} methods An object that stores key-value pairs between the names of the commands & the functions they execute.
   * @param {{ disableInline?: Boolean, disableInterpretedOptimization?: boolean, permissive?: boolean, compatible?: boolean }} options
   */
  constructor (
    methods = defaultMethods$1,
    options = { disableInline: false, disableInterpretedOptimization: false, permissive: false }
  ) {
    this.methods = { ...methods }
    /** @type {{disableInline?: Boolean, disableInterpretedOptimization?: Boolean }} */
    this.options = { disableInline: options.disableInline, disableInterpretedOptimization: options.disableInterpretedOptimization }
    this.disableInline = options.disableInline
    this.disableInterpretedOptimization = options.disableInterpretedOptimization
    this.async = true
    this.fallback = new LogicEngine(methods, options)

    if (options.compatible) applyPatches(this)

    this.optimizedMap = new WeakMap()
    this.missesSinceSeen = 0

    if (!this.isData) {
      if (!options.permissive) this.isData = () => false
      else this.isData = (data, key) => !(key in this.methods)
    }

    this.fallback.isData = this.isData
  }

  /**
   * Determines the truthiness of a value.
   * You can override this method to change the way truthiness is determined.
   * @param {*} value
   * @returns
   */
  truthy (value) {
    return value
  }

  /**
   * An internal method used to parse through the JSON Logic at a lower level.
   * @param {*} logic The logic being executed.
   * @param {*} context The context of the logic being run (input to the function.)
   * @param {*} above The context above (can be used for handlebars-style data traversal.)
   * @returns {Promise<*>}
   */
  async _parse (logic, context, above) {
    const [func] = Object.keys(logic)
    const data = logic[func]

    if (this.isData(logic, func)) return logic
    if (!this.methods[func]) throw new Error(`Method '${func}' was not found in the Logic Engine.`)

    if (typeof this.methods[func] === 'function') {
      const input = (!data || typeof data !== 'object') ? [data] : await this.run(data, context, { above })
      const result = await this.methods[func](coerceArray(input), context, above, this)
      return Array.isArray(result) ? Promise.all(result) : result
    }

    if (typeof this.methods[func] === 'object') {
      const { asyncMethod, method, traverse } = this.methods[func]
      const shouldTraverse = typeof traverse === 'undefined' ? true : traverse
      const parsedData = shouldTraverse ? ((!data || typeof data !== 'object') ? [data] : coerceArray(await this.run(data, context, { above }))) : data
      const result = await (asyncMethod || method)(parsedData, context, above, this)
      return Array.isArray(result) ? Promise.all(result) : result
    }

    throw new Error(`Method '${func}' is not set up properly.`)
  }

  /**
   *
   * @param {String} name The name of the method being added.
   * @param {((args: any, context: any, above: any[], engine: AsyncLogicEngine) => any) | { traverse?: Boolean, method?: (args: any, context: any, above: any[], engine: AsyncLogicEngine) => any, asyncMethod?: (args: any, context: any, above: any[], engine: AsyncLogicEngine) => Promise<any>, deterministic?: Function | Boolean }} method
   * @param {{ deterministic?: Boolean, async?: Boolean, sync?: Boolean, optimizeUnary?: boolean }} annotations This is used by the compiler to help determine if it can optimize the function being generated.
   */
  addMethod (
    name,
    method,
    { deterministic, async, sync, optimizeUnary } = {}
  ) {
    if (typeof async === 'undefined' && typeof sync === 'undefined') sync = false
    if (typeof sync !== 'undefined') async = !sync
    if (typeof async !== 'undefined') sync = !async

    if (typeof method === 'function') {
      if (async) method = { asyncMethod: method, traverse: true }
      else method = { method, traverse: true }
    } else method = { ...method }

    Object.assign(method, omitUndefined({ deterministic, optimizeUnary }))
    // @ts-ignore
    this.fallback.addMethod(name, method, { deterministic })
    this.methods[name] = declareSync(method, sync)
  }

  /**
   * Adds a batch of functions to the engine
   * @param {String} name
   * @param {Object} obj
   * @param {{ deterministic?: Boolean, async?: Boolean, sync?: Boolean }} annotations Not recommended unless you're sure every function from the module will match these annotations.
   */
  addModule (name, obj, annotations = {}) {
    Object.getOwnPropertyNames(obj).forEach((key) => {
      if (typeof obj[key] === 'function' || typeof obj[key] === 'object') this.addMethod(`${name}${name ? '.' : ''}${key}`, obj[key], annotations)
    })
  }

  /**
   * Runs the logic against the data.
   *
   * NOTE: With interpreted optimizations enabled, it will cache the execution plan for the logic for
   * future invocations; if you plan to modify the logic, you should disable this feature, by passing
   * `disableInterpretedOptimization: true` in the constructor.
   *
   * If it detects that a bunch of dynamic objects are being passed in, and it doesn't see the same object,
   * it will disable the interpreted optimization.
   *
   * @param {*} logic The logic to be executed
   * @param {*} data The data being passed in to the logic to be executed against.
   * @param {{ above?: any }} options Options for the invocation
   * @returns {Promise}
   */
  async run (logic, data = {}, options = {}) {
    const { above = [] } = options

    // OPTIMIZER BLOCK //
    if (this.missesSinceSeen > 500) {
      this.disableInterpretedOptimization = true
      this.missesSinceSeen = 0
    }

    if (!this.disableInterpretedOptimization && typeof logic === 'object' && logic && !this.optimizedMap.has(logic)) {
      this.optimizedMap.set(logic, optimize(logic, this, above))
      this.missesSinceSeen++
      return typeof this.optimizedMap.get(logic) === 'function' ? this.optimizedMap.get(logic)(data, above) : this.optimizedMap.get(logic)
    }

    if (!this.disableInterpretedOptimization && logic && typeof logic === 'object' && this.optimizedMap.get(logic)) {
      this.missesSinceSeen = 0
      return typeof this.optimizedMap.get(logic) === 'function' ? this.optimizedMap.get(logic)(data, above) : this.optimizedMap.get(logic)
    }
    // END OPTIMIZER BLOCK //

    if (Array.isArray(logic)) {
      const res = []
      // Note: In the past, it used .map and Promise.all; this can be changed in the future
      // if we want it to run concurrently.
      for (let i = 0; i < logic.length; i++) res.push(await this.run(logic[i], data, { above }))
      return res
    }

    if (logic && typeof logic === 'object' && Object.keys(logic).length > 0) return this._parse(logic, data, above)

    return logic
  }

  /**
   *
   * @param {*} logic The logic to be built.
   * @param {{ top?: Boolean, above?: any }} options
   * @returns {Promise<Function>}
   */
  async build (logic, options = {}) {
    const { above = [], top = true } = options
    this.fallback.truthy = this.truthy
    // @ts-ignore
    this.fallback.allowFunctions = this.allowFunctions
    if (top) {
      const constructedFunction = await buildAsync(logic, { engine: this, above, async: true, state: {} })

      const result = declareSync((...args) => {
        if (top === true) {
          try {
            const result = typeof constructedFunction === 'function' ? constructedFunction(...args) : constructedFunction
            return Promise.resolve(result)
          } catch (err) {
            return Promise.reject(err)
          }
        }

        return typeof constructedFunction === 'function' ? constructedFunction(...args) : constructedFunction
      }, top !== true && isSync(constructedFunction))
      return typeof constructedFunction === 'function' || top === true ? result : constructedFunction
    }
    return logic
  }
}
Object.assign(AsyncLogicEngine.prototype.truthy, { IDENTITY: true })

/**
 * @param {string[]} keep
 * @param {{ [key:string]: any }} obj
 */
function pick (keep, obj) {
  return Object.keys(obj).reduce((acc, i) => {
    if (keep.includes(i)) acc[i] = obj[i]
    return acc
  }, {})
}

/**
 * Takes functions and makes it possible to use them in a locked-down json-logic document.
 * @param {{ [key: string]: (...args: any[]) => any }} functions Functions to import into the engine.
 * @param {string[]} keep Methods to keep from the original logic engine
 * @returns {(...args: any[]) => (...args: any[]) => any}
 */
function asLogicSync (functions, keep = ['var'], engine = new LogicEngine()) {
  engine.methods = pick(keep, engine.methods)
  engine.addMethod('list', i => [].concat(i))
  Object.keys(functions).forEach(i => engine.addMethod(i, data => functions[i](...data)))
  return engine.build.bind(engine)
}

/**
 * Takes functions and makes it possible to use them in a locked-down json-logic document.
 * If performance becomes a problem, you may wish to optimize by creating a "new AsyncLogicEngine" yourself,
 * and adding the methods you're using as sync / async respectively. .addMethod(name, func, { sync: true })
 * This is meant to be a simple adapter.
 *
 * @param {{ [key: string]: (...args: any[]) => any }} functions
 * @param {string[]} keep
 * @returns {(...args: any[]) => Promise<(...args: any[]) => Promise<any>>}
 */
function asLogicAsync (functions, keep = ['var']) {
  return asLogicSync(functions, keep, new AsyncLogicEngine())
}

// @ts-check

const index = { LogicEngine, AsyncLogicEngine, Compiler, Constants, defaultMethods: defaultMethods$1, asLogicSync, asLogicAsync, splitPath, splitPathMemoized }

export { AsyncLogicEngine, Compiler, Constants, LogicEngine, asLogicAsync, asLogicSync, index as default, defaultMethods$1 as defaultMethods, splitPath, splitPathMemoized }
