export default AsyncLogicEngine;
/**
 * An engine capable of running asynchronous JSON Logic.
 */
declare class AsyncLogicEngine {
    /**
     * Creates a new instance of the Logic Engine.
     *
     * "compatible" applies a few patches to make it compatible with the preferences of mainline JSON Logic.
     * The main changes are:
     * - In mainline: "all" will return false if the array is empty; by default, we return true.
     * - In mainline: empty arrays are falsey; in our implementation, they are truthy.
     *
     * @param {Object} methods An object that stores key-value pairs between the names of the commands & the functions they execute.
     * @param {{ disableInline?: Boolean, disableInterpretedOptimization?: boolean, permissive?: boolean, compatible?: boolean }} options
     */
    constructor(methods?: any, options?: {
        disableInline?: boolean;
        disableInterpretedOptimization?: boolean;
        permissive?: boolean;
        compatible?: boolean;
    });
    methods: any;
    /** @type {{disableInline?: Boolean, disableInterpretedOptimization?: Boolean }} */
    options: {
        disableInline?: boolean;
        disableInterpretedOptimization?: boolean;
    };
    disableInline: boolean;
    disableInterpretedOptimization: boolean;
    async: boolean;
    fallback: LogicEngine;
    optimizedMap: WeakMap<object, any>;
    missesSinceSeen: number;
    isData: (data: any, key: any) => boolean;
    /**
     * Determines the truthiness of a value.
     * You can override this method to change the way truthiness is determined.
     * @param {*} value
     * @returns
     */
    truthy(value: any): any;
    /**
     * An internal method used to parse through the JSON Logic at a lower level.
     * @param {*} logic The logic being executed.
     * @param {*} context The context of the logic being run (input to the function.)
     * @param {*} above The context above (can be used for handlebars-style data traversal.)
     * @returns {Promise<*>}
     */
    _parse(logic: any, context: any, above: any): Promise<any>;
    /**
     *
     * @param {String} name The name of the method being added.
     * @param {((args: any, context: any, above: any[], engine: AsyncLogicEngine) => any) | { traverse?: Boolean, method?: (args: any, context: any, above: any[], engine: AsyncLogicEngine) => any, asyncMethod?: (args: any, context: any, above: any[], engine: AsyncLogicEngine) => Promise<any>, deterministic?: Function | Boolean }} method
     * @param {{ deterministic?: Boolean, async?: Boolean, sync?: Boolean, optimizeUnary?: boolean }} annotations This is used by the compiler to help determine if it can optimize the function being generated.
     */
    addMethod(name: string, method: {
        traverse?: boolean;
        method?: (args: any, context: any, above: any[], engine: AsyncLogicEngine) => any;
        asyncMethod?: (args: any, context: any, above: any[], engine: AsyncLogicEngine) => Promise<any>;
        deterministic?: Function | boolean;
    } | ((args: any, context: any, above: any[], engine: AsyncLogicEngine) => any), { deterministic, async, sync, optimizeUnary }?: {
        deterministic?: boolean;
        async?: boolean;
        sync?: boolean;
        optimizeUnary?: boolean;
    }): void;
    /**
     * Adds a batch of functions to the engine
     * @param {String} name
     * @param {Object} obj
     * @param {{ deterministic?: Boolean, async?: Boolean, sync?: Boolean }} annotations Not recommended unless you're sure every function from the module will match these annotations.
     */
    addModule(name: string, obj: any, annotations?: {
        deterministic?: boolean;
        async?: boolean;
        sync?: boolean;
    }): void;
    /**
     * Runs the logic against the data.
     *
     * NOTE: With interpreted optimizations enabled, it will cache the execution plan for the logic for
     * future invocations; if you plan to modify the logic, you should disable this feature, by passing
     * `disableInterpretedOptimization: true` in the constructor.
     *
     * If it detects that a bunch of dynamic objects are being passed in, and it doesn't see the same object,
     * it will disable the interpreted optimization.
     *
     * @param {*} logic The logic to be executed
     * @param {*} data The data being passed in to the logic to be executed against.
     * @param {{ above?: any }} options Options for the invocation
     * @returns {Promise}
     */
    run(logic: any, data?: any, options?: {
        above?: any;
    }): Promise<any>;
    /**
     *
     * @param {*} logic The logic to be built.
     * @param {{ top?: Boolean, above?: any }} options
     * @returns {Promise<Function>}
     */
    build(logic: any, options?: {
        top?: boolean;
        above?: any;
    }): Promise<Function>;
}
import LogicEngine from "./logic.js";
