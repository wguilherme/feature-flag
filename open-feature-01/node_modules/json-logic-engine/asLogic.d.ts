/**
 * Takes functions and makes it possible to use them in a locked-down json-logic document.
 * @param {{ [key: string]: (...args: any[]) => any }} functions Functions to import into the engine.
 * @param {string[]} keep Methods to keep from the original logic engine
 * @returns {(...args: any[]) => (...args: any[]) => any}
 */
export function asLogicSync(functions: {
    [key: string]: (...args: any[]) => any;
}, keep?: string[], engine?: LogicEngine): (...args: any[]) => (...args: any[]) => any;
/**
 * Takes functions and makes it possible to use them in a locked-down json-logic document.
 * If performance becomes a problem, you may wish to optimize by creating a "new AsyncLogicEngine" yourself,
 * and adding the methods you're using as sync / async respectively. .addMethod(name, func, { sync: true })
 * This is meant to be a simple adapter.
 *
 * @param {{ [key: string]: (...args: any[]) => any }} functions
 * @param {string[]} keep
 * @returns {(...args: any[]) => Promise<(...args: any[]) => Promise<any>>}
 */
export function asLogicAsync(functions: {
    [key: string]: (...args: any[]) => any;
}, keep?: string[]): (...args: any[]) => Promise<(...args: any[]) => Promise<any>>;
import LogicEngine from "./logic.js";
