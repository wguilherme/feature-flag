export default LogicEngine;
/**
 * An engine capable of running synchronous JSON Logic.
 */
declare class LogicEngine {
    /**
     * Creates a new instance of the Logic Engine.
     *
     * "compatible" applies a few patches to make it compatible with the preferences of mainline JSON Logic.
     * The main changes are:
     * - In mainline: "all" will return false if the array is empty; by default, we return true.
     * - In mainline: empty arrays are falsey; in our implementation, they are truthy.
     *
     * @param {Object} methods An object that stores key-value pairs between the names of the commands & the functions they execute.
     * @param {{ disableInline?: Boolean, disableInterpretedOptimization?: Boolean, permissive?: boolean, compatible?: boolean }} options
     */
    constructor(methods?: any, options?: {
        disableInline?: boolean;
        disableInterpretedOptimization?: boolean;
        permissive?: boolean;
        compatible?: boolean;
    });
    disableInline: boolean;
    disableInterpretedOptimization: boolean;
    methods: any;
    optimizedMap: WeakMap<object, any>;
    missesSinceSeen: number;
    /** @type {{ disableInline?: Boolean, disableInterpretedOptimization?: Boolean }} */
    options: {
        disableInline?: boolean;
        disableInterpretedOptimization?: boolean;
    };
    isData: (data: any, key: any) => boolean;
    /**
     * Determines the truthiness of a value.
     * You can override this method to change the way truthiness is determined.
     * @param {*} value
     * @returns
     */
    truthy(value: any): any;
    /**
     * An internal method used to parse through the JSON Logic at a lower level.
     * @param {*} logic The logic being executed.
     * @param {*} context The context of the logic being run (input to the function.)
     * @param {*} above The context above (can be used for handlebars-style data traversal.)
     * @returns {{ result: *, func: string }}
     */
    _parse(logic: any, context: any, above: any): {
        result: any;
        func: string;
    };
    /**
     *
     * @param {String} name The name of the method being added.
     * @param {((args: any, context: any, above: any[], engine: LogicEngine) => any) |{ traverse?: Boolean, method: (args: any, context: any, above: any[], engine: LogicEngine) => any, deterministic?: Function | Boolean }} method
     * @param {{ deterministic?: Boolean, optimizeUnary?: Boolean }} annotations This is used by the compiler to help determine if it can optimize the function being generated.
     */
    addMethod(name: string, method: {
        traverse?: boolean;
        method: (args: any, context: any, above: any[], engine: LogicEngine) => any;
        deterministic?: Function | boolean;
    } | ((args: any, context: any, above: any[], engine: LogicEngine) => any), { deterministic, optimizeUnary }?: {
        deterministic?: boolean;
        optimizeUnary?: boolean;
    }): void;
    /**
     * Adds a batch of functions to the engine
     * @param {String} name
     * @param {Object} obj
     * @param {{ deterministic?: Boolean, async?: Boolean, sync?: Boolean }} annotations Not recommended unless you're sure every function from the module will match these annotations.
     */
    addModule(name: string, obj: any, annotations: {
        deterministic?: boolean;
        async?: boolean;
        sync?: boolean;
    }): void;
    /**
     * Runs the logic against the data.
     *
     * NOTE: With interpreted optimizations enabled, it will cache the execution plan for the logic for
     * future invocations; if you plan to modify the logic, you should disable this feature, by passing
     * `disableInterpretedOptimization: true` in the constructor.
     *
     * If it detects that a bunch of dynamic objects are being passed in, and it doesn't see the same object,
     * it will disable the interpreted optimization.
     *
     * @param {*} logic The logic to be executed
     * @param {*} data The data being passed in to the logic to be executed against.
     * @param {{ above?: any }} options Options for the invocation
     * @returns {*}
     */
    run(logic: any, data?: any, options?: {
        above?: any;
    }): any;
    /**
     *
     * @param {*} logic The logic to be built.
     * @param {{ top?: Boolean, above?: any }} options
     * @returns {Function}
     */
    build(logic: any, options?: {
        top?: boolean;
        above?: any;
    }): Function;
}
