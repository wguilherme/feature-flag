import { CallOptions, ChannelCredentials, Client, ClientOptions, ClientReadableStream, ClientUnaryCall, handleServerStreamingCall, handleUnaryCall, Metadata, ServiceError, UntypedServiceImplementation } from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "schema.v1";
/**
 * DEPRECATED; use flagd.evaluation.v1
 * Flag evaluation API
 *
 * This proto forms the basis of a flag-evaluation API.
 * It supports single and bulk evaluation RPCs, and flags of various types, as well as establishing a stream for getting notifications about changes in a flag definition.
 * It supports the inclusion of a "context" with each evaluation, which may contain arbitrary attributes relevant to flag evaluation.
 *
 * @deprecated
 */
/** Request body for bulk flag evaluation, used by the ResolveAll rpc. */
export interface ResolveAllRequest {
    /** Object structure describing the EvaluationContext used in the flag evaluation, see https://openfeature.dev/docs/reference/concepts/evaluation-context */
    context: {
        [key: string]: any;
    } | undefined;
}
/** Response body for bulk flag evaluation, used by the ResolveAll rpc. */
export interface ResolveAllResponse {
    /** Object structure describing the evaluated flags for the provided context. */
    flags: {
        [key: string]: AnyFlag;
    };
}
export interface ResolveAllResponse_FlagsEntry {
    key: string;
    value: AnyFlag | undefined;
}
/** A variant type flag response. */
export interface AnyFlag {
    /** The reason for the given return value, see https://openfeature.dev/docs/specification/types#resolution-details */
    reason: string;
    /** The variant name of the returned flag value. */
    variant: string;
    boolValue?: boolean | undefined;
    stringValue?: string | undefined;
    doubleValue?: number | undefined;
    objectValue?: {
        [key: string]: any;
    } | undefined;
}
/** Request body for boolean flag evaluation, used by the ResolveBoolean rpc. */
export interface ResolveBooleanRequest {
    /** Flag key of the requested flag. */
    flagKey: string;
    /** Object structure describing the EvaluationContext used in the flag evaluation, see https://openfeature.dev/docs/reference/concepts/evaluation-context */
    context: {
        [key: string]: any;
    } | undefined;
}
/** Response body for boolean flag evaluation. used by the ResolveBoolean rpc. */
export interface ResolveBooleanResponse {
    /** The response value of the boolean flag evaluation, will be unset in the case of error. */
    value: boolean;
    /** The reason for the given return value, see https://openfeature.dev/docs/specification/types#resolution-details */
    reason: string;
    /** The variant name of the returned flag value. */
    variant: string;
    /** Metadata for this evaluation */
    metadata: {
        [key: string]: any;
    } | undefined;
}
/** Request body for string flag evaluation, used by the ResolveString rpc. */
export interface ResolveStringRequest {
    /** Flag key of the requested flag. */
    flagKey: string;
    /** Object structure describing the EvaluationContext used in the flag evaluation, see https://openfeature.dev/docs/reference/concepts/evaluation-context */
    context: {
        [key: string]: any;
    } | undefined;
}
/** Response body for string flag evaluation. used by the ResolveString rpc. */
export interface ResolveStringResponse {
    /** The response value of the string flag evaluation, will be unset in the case of error. */
    value: string;
    /** The reason for the given return value, see https://openfeature.dev/docs/specification/types#resolution-details */
    reason: string;
    /** The variant name of the returned flag value. */
    variant: string;
    /** Metadata for this evaluation */
    metadata: {
        [key: string]: any;
    } | undefined;
}
/** Request body for float flag evaluation, used by the ResolveFloat rpc. */
export interface ResolveFloatRequest {
    /** Flag key of the requested flag. */
    flagKey: string;
    /** Object structure describing the EvaluationContext used in the flag evaluation, see https://openfeature.dev/docs/reference/concepts/evaluation-context */
    context: {
        [key: string]: any;
    } | undefined;
}
/** Response body for float flag evaluation. used by the ResolveFloat rpc. */
export interface ResolveFloatResponse {
    /** The response value of the float flag evaluation, will be empty in the case of error. */
    value: number;
    /** The reason for the given return value, see https://openfeature.dev/docs/specification/types#resolution-details */
    reason: string;
    /** The variant name of the returned flag value. */
    variant: string;
    /** Metadata for this evaluation */
    metadata: {
        [key: string]: any;
    } | undefined;
}
/** Request body for int flag evaluation, used by the ResolveInt rpc. */
export interface ResolveIntRequest {
    /** Flag key of the requested flag. */
    flagKey: string;
    /** Object structure describing the EvaluationContext used in the flag evaluation, see https://openfeature.dev/docs/reference/concepts/evaluation-context */
    context: {
        [key: string]: any;
    } | undefined;
}
/** Response body for int flag evaluation. used by the ResolveInt rpc. */
export interface ResolveIntResponse {
    /** The response value of the int flag evaluation, will be unset in the case of error. */
    value: string;
    /** The reason for the given return value, see https://openfeature.dev/docs/specification/types#resolution-details */
    reason: string;
    /** The variant name of the returned flag value. */
    variant: string;
    /** Metadata for this evaluation */
    metadata: {
        [key: string]: any;
    } | undefined;
}
/** Request body for object flag evaluation, used by the ResolveObject rpc. */
export interface ResolveObjectRequest {
    /** Flag key of the requested flag. */
    flagKey: string;
    /** Object structure describing the EvaluationContext used in the flag evaluation, see https://openfeature.dev/docs/reference/concepts/evaluation-context */
    context: {
        [key: string]: any;
    } | undefined;
}
/** Response body for object flag evaluation. used by the ResolveObject rpc. */
export interface ResolveObjectResponse {
    /**
     * The response value of the object flag evaluation, will be unset in the case of error.
     *
     * NOTE: This structure will need to be decoded from google/protobuf/struct.proto before it is returned to the SDK
     */
    value: {
        [key: string]: any;
    } | undefined;
    /** The reason for the given return value, see https://openfeature.dev/docs/specification/types#resolution-details */
    reason: string;
    /** The variant name of the returned flag value. */
    variant: string;
    /** Metadata for this evaluation */
    metadata: {
        [key: string]: any;
    } | undefined;
}
/** Response body for the EventStream stream response */
export interface EventStreamResponse {
    /** String key indicating the type of event that is being received, for example, provider_ready or configuration_change */
    type: string;
    /**
     * Object structure for use when sending relevant metadata to provide context to the event.
     * Can be left unset when it is not required.
     */
    data: {
        [key: string]: any;
    } | undefined;
}
/** Empty stream request body */
export interface EventStreamRequest {
}
export declare const ResolveAllRequest: {
    encode(message: ResolveAllRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveAllRequest;
    fromJSON(object: any): ResolveAllRequest;
    toJSON(message: ResolveAllRequest): unknown;
    create<I extends Exact<DeepPartial<ResolveAllRequest>, I>>(base?: I): ResolveAllRequest;
    fromPartial<I extends Exact<DeepPartial<ResolveAllRequest>, I>>(object: I): ResolveAllRequest;
};
export declare const ResolveAllResponse: {
    encode(message: ResolveAllResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveAllResponse;
    fromJSON(object: any): ResolveAllResponse;
    toJSON(message: ResolveAllResponse): unknown;
    create<I extends Exact<DeepPartial<ResolveAllResponse>, I>>(base?: I): ResolveAllResponse;
    fromPartial<I extends Exact<DeepPartial<ResolveAllResponse>, I>>(object: I): ResolveAllResponse;
};
export declare const ResolveAllResponse_FlagsEntry: {
    encode(message: ResolveAllResponse_FlagsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveAllResponse_FlagsEntry;
    fromJSON(object: any): ResolveAllResponse_FlagsEntry;
    toJSON(message: ResolveAllResponse_FlagsEntry): unknown;
    create<I extends Exact<DeepPartial<ResolveAllResponse_FlagsEntry>, I>>(base?: I): ResolveAllResponse_FlagsEntry;
    fromPartial<I extends Exact<DeepPartial<ResolveAllResponse_FlagsEntry>, I>>(object: I): ResolveAllResponse_FlagsEntry;
};
export declare const AnyFlag: {
    encode(message: AnyFlag, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AnyFlag;
    fromJSON(object: any): AnyFlag;
    toJSON(message: AnyFlag): unknown;
    create<I extends Exact<DeepPartial<AnyFlag>, I>>(base?: I): AnyFlag;
    fromPartial<I extends Exact<DeepPartial<AnyFlag>, I>>(object: I): AnyFlag;
};
export declare const ResolveBooleanRequest: {
    encode(message: ResolveBooleanRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveBooleanRequest;
    fromJSON(object: any): ResolveBooleanRequest;
    toJSON(message: ResolveBooleanRequest): unknown;
    create<I extends Exact<DeepPartial<ResolveBooleanRequest>, I>>(base?: I): ResolveBooleanRequest;
    fromPartial<I extends Exact<DeepPartial<ResolveBooleanRequest>, I>>(object: I): ResolveBooleanRequest;
};
export declare const ResolveBooleanResponse: {
    encode(message: ResolveBooleanResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveBooleanResponse;
    fromJSON(object: any): ResolveBooleanResponse;
    toJSON(message: ResolveBooleanResponse): unknown;
    create<I extends Exact<DeepPartial<ResolveBooleanResponse>, I>>(base?: I): ResolveBooleanResponse;
    fromPartial<I extends Exact<DeepPartial<ResolveBooleanResponse>, I>>(object: I): ResolveBooleanResponse;
};
export declare const ResolveStringRequest: {
    encode(message: ResolveStringRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveStringRequest;
    fromJSON(object: any): ResolveStringRequest;
    toJSON(message: ResolveStringRequest): unknown;
    create<I extends Exact<DeepPartial<ResolveStringRequest>, I>>(base?: I): ResolveStringRequest;
    fromPartial<I extends Exact<DeepPartial<ResolveStringRequest>, I>>(object: I): ResolveStringRequest;
};
export declare const ResolveStringResponse: {
    encode(message: ResolveStringResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveStringResponse;
    fromJSON(object: any): ResolveStringResponse;
    toJSON(message: ResolveStringResponse): unknown;
    create<I extends Exact<DeepPartial<ResolveStringResponse>, I>>(base?: I): ResolveStringResponse;
    fromPartial<I extends Exact<DeepPartial<ResolveStringResponse>, I>>(object: I): ResolveStringResponse;
};
export declare const ResolveFloatRequest: {
    encode(message: ResolveFloatRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveFloatRequest;
    fromJSON(object: any): ResolveFloatRequest;
    toJSON(message: ResolveFloatRequest): unknown;
    create<I extends Exact<DeepPartial<ResolveFloatRequest>, I>>(base?: I): ResolveFloatRequest;
    fromPartial<I extends Exact<DeepPartial<ResolveFloatRequest>, I>>(object: I): ResolveFloatRequest;
};
export declare const ResolveFloatResponse: {
    encode(message: ResolveFloatResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveFloatResponse;
    fromJSON(object: any): ResolveFloatResponse;
    toJSON(message: ResolveFloatResponse): unknown;
    create<I extends Exact<DeepPartial<ResolveFloatResponse>, I>>(base?: I): ResolveFloatResponse;
    fromPartial<I extends Exact<DeepPartial<ResolveFloatResponse>, I>>(object: I): ResolveFloatResponse;
};
export declare const ResolveIntRequest: {
    encode(message: ResolveIntRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveIntRequest;
    fromJSON(object: any): ResolveIntRequest;
    toJSON(message: ResolveIntRequest): unknown;
    create<I extends Exact<DeepPartial<ResolveIntRequest>, I>>(base?: I): ResolveIntRequest;
    fromPartial<I extends Exact<DeepPartial<ResolveIntRequest>, I>>(object: I): ResolveIntRequest;
};
export declare const ResolveIntResponse: {
    encode(message: ResolveIntResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveIntResponse;
    fromJSON(object: any): ResolveIntResponse;
    toJSON(message: ResolveIntResponse): unknown;
    create<I extends Exact<DeepPartial<ResolveIntResponse>, I>>(base?: I): ResolveIntResponse;
    fromPartial<I extends Exact<DeepPartial<ResolveIntResponse>, I>>(object: I): ResolveIntResponse;
};
export declare const ResolveObjectRequest: {
    encode(message: ResolveObjectRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveObjectRequest;
    fromJSON(object: any): ResolveObjectRequest;
    toJSON(message: ResolveObjectRequest): unknown;
    create<I extends Exact<DeepPartial<ResolveObjectRequest>, I>>(base?: I): ResolveObjectRequest;
    fromPartial<I extends Exact<DeepPartial<ResolveObjectRequest>, I>>(object: I): ResolveObjectRequest;
};
export declare const ResolveObjectResponse: {
    encode(message: ResolveObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResolveObjectResponse;
    fromJSON(object: any): ResolveObjectResponse;
    toJSON(message: ResolveObjectResponse): unknown;
    create<I extends Exact<DeepPartial<ResolveObjectResponse>, I>>(base?: I): ResolveObjectResponse;
    fromPartial<I extends Exact<DeepPartial<ResolveObjectResponse>, I>>(object: I): ResolveObjectResponse;
};
export declare const EventStreamResponse: {
    encode(message: EventStreamResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventStreamResponse;
    fromJSON(object: any): EventStreamResponse;
    toJSON(message: EventStreamResponse): unknown;
    create<I extends Exact<DeepPartial<EventStreamResponse>, I>>(base?: I): EventStreamResponse;
    fromPartial<I extends Exact<DeepPartial<EventStreamResponse>, I>>(object: I): EventStreamResponse;
};
export declare const EventStreamRequest: {
    encode(_: EventStreamRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventStreamRequest;
    fromJSON(_: any): EventStreamRequest;
    toJSON(_: EventStreamRequest): unknown;
    create<I extends Exact<DeepPartial<EventStreamRequest>, I>>(base?: I): EventStreamRequest;
    fromPartial<I extends Exact<DeepPartial<EventStreamRequest>, I>>(_: I): EventStreamRequest;
};
/** Service defines the exposed rpcs of flagd */
export type ServiceService = typeof ServiceService;
export declare const ServiceService: {
    readonly resolveAll: {
        readonly path: "/schema.v1.Service/ResolveAll";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: ResolveAllRequest) => Buffer<ArrayBuffer>;
        readonly requestDeserialize: (value: Buffer) => ResolveAllRequest;
        readonly responseSerialize: (value: ResolveAllResponse) => Buffer<ArrayBuffer>;
        readonly responseDeserialize: (value: Buffer) => ResolveAllResponse;
    };
    readonly resolveBoolean: {
        readonly path: "/schema.v1.Service/ResolveBoolean";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: ResolveBooleanRequest) => Buffer<ArrayBuffer>;
        readonly requestDeserialize: (value: Buffer) => ResolveBooleanRequest;
        readonly responseSerialize: (value: ResolveBooleanResponse) => Buffer<ArrayBuffer>;
        readonly responseDeserialize: (value: Buffer) => ResolveBooleanResponse;
    };
    readonly resolveString: {
        readonly path: "/schema.v1.Service/ResolveString";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: ResolveStringRequest) => Buffer<ArrayBuffer>;
        readonly requestDeserialize: (value: Buffer) => ResolveStringRequest;
        readonly responseSerialize: (value: ResolveStringResponse) => Buffer<ArrayBuffer>;
        readonly responseDeserialize: (value: Buffer) => ResolveStringResponse;
    };
    readonly resolveFloat: {
        readonly path: "/schema.v1.Service/ResolveFloat";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: ResolveFloatRequest) => Buffer<ArrayBuffer>;
        readonly requestDeserialize: (value: Buffer) => ResolveFloatRequest;
        readonly responseSerialize: (value: ResolveFloatResponse) => Buffer<ArrayBuffer>;
        readonly responseDeserialize: (value: Buffer) => ResolveFloatResponse;
    };
    readonly resolveInt: {
        readonly path: "/schema.v1.Service/ResolveInt";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: ResolveIntRequest) => Buffer<ArrayBuffer>;
        readonly requestDeserialize: (value: Buffer) => ResolveIntRequest;
        readonly responseSerialize: (value: ResolveIntResponse) => Buffer<ArrayBuffer>;
        readonly responseDeserialize: (value: Buffer) => ResolveIntResponse;
    };
    readonly resolveObject: {
        readonly path: "/schema.v1.Service/ResolveObject";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: ResolveObjectRequest) => Buffer<ArrayBuffer>;
        readonly requestDeserialize: (value: Buffer) => ResolveObjectRequest;
        readonly responseSerialize: (value: ResolveObjectResponse) => Buffer<ArrayBuffer>;
        readonly responseDeserialize: (value: Buffer) => ResolveObjectResponse;
    };
    readonly eventStream: {
        readonly path: "/schema.v1.Service/EventStream";
        readonly requestStream: false;
        readonly responseStream: true;
        readonly requestSerialize: (value: EventStreamRequest) => Buffer<ArrayBuffer>;
        readonly requestDeserialize: (value: Buffer) => EventStreamRequest;
        readonly responseSerialize: (value: EventStreamResponse) => Buffer<ArrayBuffer>;
        readonly responseDeserialize: (value: Buffer) => EventStreamResponse;
    };
};
export interface ServiceServer extends UntypedServiceImplementation {
    resolveAll: handleUnaryCall<ResolveAllRequest, ResolveAllResponse>;
    resolveBoolean: handleUnaryCall<ResolveBooleanRequest, ResolveBooleanResponse>;
    resolveString: handleUnaryCall<ResolveStringRequest, ResolveStringResponse>;
    resolveFloat: handleUnaryCall<ResolveFloatRequest, ResolveFloatResponse>;
    resolveInt: handleUnaryCall<ResolveIntRequest, ResolveIntResponse>;
    resolveObject: handleUnaryCall<ResolveObjectRequest, ResolveObjectResponse>;
    eventStream: handleServerStreamingCall<EventStreamRequest, EventStreamResponse>;
}
export interface ServiceClient extends Client {
    resolveAll(request: ResolveAllRequest, callback: (error: ServiceError | null, response: ResolveAllResponse) => void): ClientUnaryCall;
    resolveAll(request: ResolveAllRequest, metadata: Metadata, callback: (error: ServiceError | null, response: ResolveAllResponse) => void): ClientUnaryCall;
    resolveAll(request: ResolveAllRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: ResolveAllResponse) => void): ClientUnaryCall;
    resolveBoolean(request: ResolveBooleanRequest, callback: (error: ServiceError | null, response: ResolveBooleanResponse) => void): ClientUnaryCall;
    resolveBoolean(request: ResolveBooleanRequest, metadata: Metadata, callback: (error: ServiceError | null, response: ResolveBooleanResponse) => void): ClientUnaryCall;
    resolveBoolean(request: ResolveBooleanRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: ResolveBooleanResponse) => void): ClientUnaryCall;
    resolveString(request: ResolveStringRequest, callback: (error: ServiceError | null, response: ResolveStringResponse) => void): ClientUnaryCall;
    resolveString(request: ResolveStringRequest, metadata: Metadata, callback: (error: ServiceError | null, response: ResolveStringResponse) => void): ClientUnaryCall;
    resolveString(request: ResolveStringRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: ResolveStringResponse) => void): ClientUnaryCall;
    resolveFloat(request: ResolveFloatRequest, callback: (error: ServiceError | null, response: ResolveFloatResponse) => void): ClientUnaryCall;
    resolveFloat(request: ResolveFloatRequest, metadata: Metadata, callback: (error: ServiceError | null, response: ResolveFloatResponse) => void): ClientUnaryCall;
    resolveFloat(request: ResolveFloatRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: ResolveFloatResponse) => void): ClientUnaryCall;
    resolveInt(request: ResolveIntRequest, callback: (error: ServiceError | null, response: ResolveIntResponse) => void): ClientUnaryCall;
    resolveInt(request: ResolveIntRequest, metadata: Metadata, callback: (error: ServiceError | null, response: ResolveIntResponse) => void): ClientUnaryCall;
    resolveInt(request: ResolveIntRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: ResolveIntResponse) => void): ClientUnaryCall;
    resolveObject(request: ResolveObjectRequest, callback: (error: ServiceError | null, response: ResolveObjectResponse) => void): ClientUnaryCall;
    resolveObject(request: ResolveObjectRequest, metadata: Metadata, callback: (error: ServiceError | null, response: ResolveObjectResponse) => void): ClientUnaryCall;
    resolveObject(request: ResolveObjectRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: ResolveObjectResponse) => void): ClientUnaryCall;
    eventStream(request: EventStreamRequest, options?: Partial<CallOptions>): ClientReadableStream<EventStreamResponse>;
    eventStream(request: EventStreamRequest, metadata?: Metadata, options?: Partial<CallOptions>): ClientReadableStream<EventStreamResponse>;
}
export declare const ServiceClient: {
    new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ServiceClient;
    service: typeof ServiceService;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
