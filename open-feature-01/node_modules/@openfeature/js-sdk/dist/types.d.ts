type FlagValueType = 'boolean' | 'string' | 'number' | 'object';
type PrimitiveValue = null | boolean | string | number;
type JsonObject = {
    [key: string]: JsonValue;
};
type JsonArray = JsonValue[];
/**
 * Represents a JSON node value.
 */
type JsonValue = PrimitiveValue | JsonObject | JsonArray;
/**
 * Represents a JSON node value, or Date.
 */
type FlagValue = boolean | string | number | JsonValue;
type ResolutionReason = keyof typeof StandardResolutionReasons | (string & Record<never, never>);
/**
 * A structure which supports definition of arbitrary properties, with keys of type string, and values of type boolean, string, or number.
 *
 * This structure is populated by a provider for use by an Application Author (via the Evaluation API) or an Application Integrator (via hooks).
 */
type FlagMetadata = Record<string, string | number | boolean>;
type ResolutionDetails<U> = {
    value: U;
    variant?: string;
    flagMetadata?: FlagMetadata;
    reason?: ResolutionReason;
    errorCode?: ErrorCode;
    errorMessage?: string;
};
type EvaluationDetails<T extends FlagValue> = {
    flagKey: string;
    flagMetadata: Readonly<FlagMetadata>;
} & ResolutionDetails<T>;
declare const StandardResolutionReasons: {
    /**
     * The resolved value was the result of a dynamic evaluation, such as a rule or specific user-targeting.
     */
    readonly TARGETING_MATCH: "TARGETING_MATCH";
    /**
     * The resolved value was the result of pseudorandom assignment.
     */
    readonly SPLIT: "SPLIT";
    /**
     * The resolved value was the result of the flag being disabled in the management system.
     */
    readonly DISABLED: "DISABLED";
    /**
     *  The resolved value was configured statically, or otherwise fell back to a pre-configured value.
     */
    readonly DEFAULT: "DEFAULT";
    /**
     * The reason for the resolved value could not be determined.
     */
    readonly UNKNOWN: "UNKNOWN";
    /**
     * The resolved value is static (no dynamic evaluation).
     */
    readonly STATIC: "STATIC";
    /**
     * The resolved value was retrieved from cache.
     */
    readonly CACHED: "CACHED";
    /**
     * The resolved value was the result of an error.
     *
     * Note: The `errorCode` and `errorMessage` fields may contain additional details of this error.
     */
    readonly ERROR: "ERROR";
};
declare enum ErrorCode {
    /**
     * The value was resolved before the provider was ready.
     */
    PROVIDER_NOT_READY = "PROVIDER_NOT_READY",
    /**
     * The flag could not be found.
     */
    FLAG_NOT_FOUND = "FLAG_NOT_FOUND",
    /**
     * An error was encountered parsing data, such as a flag configuration.
     */
    PARSE_ERROR = "PARSE_ERROR",
    /**
     * The type of the flag value does not match the expected type.
     */
    TYPE_MISMATCH = "TYPE_MISMATCH",
    /**
     * The provider requires a targeting key and one was not provided in the evaluation context.
     */
    TARGETING_KEY_MISSING = "TARGETING_KEY_MISSING",
    /**
     * The evaluation context does not meet provider requirements.
     */
    INVALID_CONTEXT = "INVALID_CONTEXT",
    /**
     * An error with an unspecified code.
     */
    GENERAL = "GENERAL"
}

type EvaluationContextValue = PrimitiveValue | Date | {
    [key: string]: EvaluationContextValue;
} | EvaluationContextValue[];
/**
 * A container for arbitrary contextual data that can be used as a basis for dynamic evaluation
 */
type EvaluationContext = {
    /**
     * A string uniquely identifying the subject (end-user, or client service) of a flag evaluation.
     * Providers may require this field for fractional flag evaluation, rules, or overrides targeting specific users.
     * Such providers may behave unpredictably if a targeting key is not specified at flag resolution.
     */
    targetingKey?: string;
} & Record<string, EvaluationContextValue>;
interface ManageContext<T> {
    /**
     * Access the evaluation context set on the receiver.
     * @returns {EvaluationContext} Evaluation context
     */
    getContext(): EvaluationContext;
    /**
     * Sets evaluation context that will be used during flag evaluations
     * on this receiver.
     * @template T The type of the receiver
     * @param {EvaluationContext} context Evaluation context
     * @returns {T} The receiver (this object)
     */
    setContext(context: EvaluationContext): T;
}

declare enum ProviderEvents {
    /**
     * The provider is ready to evaluate flags.
     */
    Ready = "PROVIDER_READY",
    /**
     * The provider is in an error state.
     */
    Error = "PROVIDER_ERROR",
    /**
     * The flag configuration in the source-of-truth has changed.
     */
    ConfigurationChanged = "PROVIDER_CONFIGURATION_CHANGED",
    /**
     * The provider's cached state is no longer valid and may not be up-to-date with the source of truth.
     */
    Stale = "PROVIDER_STALE"
}

/**
 * Returns true if the provider's status corresponds to the event.
 * If the provider's status is not defined, it matches READY.
 * @param {ProviderEvents} event event to match
 * @param {ProviderStatus} status  status of provider
 * @returns {boolean} boolean indicating if the provider status corresponds to the event.
 */
declare const statusMatchesEvent: (event: ProviderEvents, status?: ProviderStatus) => boolean;

type EventMetadata = {
    [key: string]: string | boolean | number;
};
type CommonEventDetails = {
    providerName: string;
    clientName?: string;
};
type CommonEventProps = {
    message?: string;
    metadata?: EventMetadata;
};
type ReadyEvent = CommonEventProps;
type ErrorEvent = CommonEventProps;
type StaleEvent = CommonEventProps;
type ConfigChangeEvent = CommonEventProps & {
    flagsChanged?: string[];
};
type EventMap = {
    [ProviderEvents.Ready]: ReadyEvent;
    [ProviderEvents.Error]: ErrorEvent;
    [ProviderEvents.Stale]: StaleEvent;
    [ProviderEvents.ConfigurationChanged]: ConfigChangeEvent;
};
type EventContext<T extends ProviderEvents, U extends Record<string, unknown> = Record<string, unknown>> = EventMap[T] & U;
type EventDetails<T extends ProviderEvents> = EventContext<T> & CommonEventDetails;
type EventHandler<T extends ProviderEvents> = (eventDetails?: EventDetails<T>) => Promise<unknown> | unknown;
interface Eventing {
    /**
     * Adds a handler for the given provider event type.
     * The handlers are called in the order they have been added.
     * @param {ProviderEvents} eventType The provider event type to listen to
     * @param {EventHandler} handler The handler to run on occurrence of the event type
     */
    addHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void;
    /**
     * Removes a handler for the given provider event type.
     * @param {ProviderEvents} eventType The provider event type to remove the listener for
     * @param {EventHandler} handler The handler to remove for the provider event type
     */
    removeHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void;
    /**
     * Gets the current handlers for the given provider event type.
     * @param {ProviderEvents} eventType The provider event type to get the current handlers for
     * @returns {EventHandler[]} The handlers currently attached to the given provider event type
     */
    getHandlers<T extends ProviderEvents>(eventType: T): EventHandler<T>[];
}

interface Logger {
    error(...args: unknown[]): void;
    warn(...args: unknown[]): void;
    info(...args: unknown[]): void;
    debug(...args: unknown[]): void;
}
interface ManageLogger<T> {
    /**
     * Sets a logger on this receiver. This logger supersedes to the global logger
     * and is passed to various components in the SDK.
     * The logger configured on the global API object will be used for all evaluations,
     * unless overridden in a particular client.
     * @template T The type of the receiver
     * @param {Logger} logger The logger to be used
     * @returns {T} The receiver (this object)
     */
    setLogger(logger: Logger): T;
}

declare class DefaultLogger implements Logger {
    error(...args: unknown[]): void;
    warn(...args: unknown[]): void;
    info(): void;
    debug(): void;
}

declare const LOG_LEVELS: Array<keyof Logger>;
declare class SafeLogger implements Logger {
    private readonly logger;
    private readonly fallbackLogger;
    constructor(logger: Logger);
    error(...args: unknown[]): void;
    warn(...args: unknown[]): void;
    info(...args: unknown[]): void;
    debug(...args: unknown[]): void;
    private log;
}

declare abstract class GenericEventEmitter<AdditionalContext extends Record<string, unknown> = Record<string, unknown>> implements ManageLogger<GenericEventEmitter<AdditionalContext>> {
    private readonly globalLogger?;
    private readonly _handlers;
    private readonly eventEmitter;
    private _eventLogger?;
    constructor(globalLogger?: (() => Logger) | undefined);
    emit<T extends ProviderEvents>(eventType: T, context?: EventContext<T, AdditionalContext>): void;
    addHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void;
    removeHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void;
    removeAllHandlers(eventType?: ProviderEvents): void;
    getHandlers<T extends ProviderEvents>(eventType: T): EventHandler<T>[];
    setLogger(logger: Logger): this;
    private get _logger();
}
/**
 * The OpenFeatureEventEmitter can be used by provider developers to emit
 * events at various parts of the provider lifecycle.
 *
 * NOTE: Ready and error events are automatically emitted by the SDK based on
 * the result of the initialize method.
 */
declare class OpenFeatureEventEmitter extends GenericEventEmitter {
}
/**
 * The InternalEventEmitter should only be used within the SDK. It extends the
 * OpenFeatureEventEmitter to include additional properties that can be included
 * in the event details.
 */
declare class InternalEventEmitter extends GenericEventEmitter<CommonEventDetails> {
}

interface Metadata {
}

/**
 * Defines where the library is intended to be run.
 */
type Paradigm = 'server' | 'client';

/**
 * The state of the provider.
 */
declare enum ProviderStatus {
    /**
     * The provider has not been initialized and cannot yet evaluate flags.
     */
    NOT_READY = "NOT_READY",
    /**
     * The provider is ready to resolve flags.
     */
    READY = "READY",
    /**
     * The provider is in an error state and unable to evaluate flags.
     */
    ERROR = "ERROR",
    /**
     * The provider's cached state is no longer valid and may not be up-to-date with the source of truth.
     */
    STALE = "STALE"
}
/**
 * Static data about the provider.
 */
interface ProviderMetadata extends Metadata {
    readonly name: string;
}
interface CommonProvider {
    readonly metadata: ProviderMetadata;
    /**
     * Represents where the provider is intended to be run. If defined,
     * the SDK will enforce that the defined paradigm at runtime.
     */
    readonly runsOn?: Paradigm;
    /**
     * Returns a representation of the current readiness of the provider.
     * If the provider needs to be initialized, it should return {@link ProviderStatus.READY}.
     * If the provider is in an error state, it should return {@link ProviderStatus.ERROR}.
     * If the provider is functioning normally, it should return {@link ProviderStatus.NOT_READY}.
     *
     * _Providers which do not implement this method are assumed to be ready immediately._
     */
    readonly status?: ProviderStatus;
    /**
     * An event emitter for ProviderEvents.
     * @see ProviderEvents
     */
    events?: OpenFeatureEventEmitter;
    /**
     * A function used to shut down the provider.
     * Called when this provider is replaced with a new one, or when the OpenFeature is shut down.
     */
    onClose?(): Promise<void>;
    /**
     * A function used to setup the provider.
     * Called by the SDK after the provider is set if the provider's status is {@link ProviderStatus.NOT_READY}.
     * When the returned promise resolves, the SDK fires the ProviderEvents.Ready event.
     * If the returned promise rejects, the SDK fires the ProviderEvents.Error event.
     * Use this function to perform any context-dependent setup within the provider.
     * @param context
     */
    initialize?(context?: EvaluationContext): Promise<void>;
}

interface ClientMetadata extends Metadata {
    readonly version?: string;
    readonly name?: string;
    readonly providerMetadata: ProviderMetadata;
}

type HookHints = Readonly<Record<string, unknown>>;
interface HookContext<T extends FlagValue = FlagValue> {
    readonly flagKey: string;
    readonly defaultValue: T;
    readonly flagValueType: FlagValueType;
    readonly context: Readonly<EvaluationContext>;
    readonly clientMetadata: ClientMetadata;
    readonly providerMetadata: ProviderMetadata;
    readonly logger: Logger;
}
interface BeforeHookContext extends HookContext {
    context: EvaluationContext;
}

interface Hook<T extends FlagValue = FlagValue> {
    /**
     * Runs before flag values are resolved from the provider.
     * If an EvaluationContext is returned, it will be merged with the pre-existing EvaluationContext.
     * @param hookContext
     * @param hookHints
     */
    before?(hookContext: BeforeHookContext, hookHints?: HookHints): Promise<EvaluationContext | void> | EvaluationContext | void;
    /**
     * Runs after flag values are successfully resolved from the provider.
     * @param hookContext
     * @param evaluationDetails
     * @param hookHints
     */
    after?(hookContext: Readonly<HookContext<T>>, evaluationDetails: EvaluationDetails<T>, hookHints?: HookHints): Promise<void> | void;
    /**
     * Runs in the event of an unhandled error or promise rejection during flag resolution, or any attached hooks.
     * @param hookContext
     * @param error
     * @param hookHints
     */
    error?(hookContext: Readonly<HookContext<T>>, error: unknown, hookHints?: HookHints): Promise<void> | void;
    /**
     * Runs after all other hook stages, regardless of success or error.
     * Errors thrown here are unhandled by the client and will surface in application code.
     * @param hookContext
     * @param hookHints
     */
    finally?(hookContext: Readonly<HookContext<T>>, hookHints?: HookHints): Promise<void> | void;
}

interface EvaluationLifeCycle<T> {
    /**
     * Adds hooks that will run during flag evaluations on this receiver.
     * Hooks are executed in the order they were registered. Adding additional hooks
     * will not remove existing hooks.
     * Hooks registered on the global API object run with all evaluations.
     * Hooks registered on the client run with all evaluations on that client.
     * @template T The type of the receiver
     * @param {Hook<FlagValue>[]} hooks A list of hooks that should always run
     * @returns {T} The receiver (this object)
     */
    addHooks(...hooks: Hook<FlagValue>[]): T;
    /**
     * Access all the hooks that are registered on this receiver.
     * @returns {Hook<FlagValue>[]} A list of the client hooks
     */
    getHooks(): Hook<FlagValue>[];
    /**
     * Clears all the hooks that are registered on this receiver.
     * @template T The type of the receiver
     * @returns {T} The receiver (this object)
     */
    clearHooks(): T;
}

declare abstract class OpenFeatureError extends Error {
    abstract code: ErrorCode;
    constructor(message?: string);
}

declare class GeneralError extends OpenFeatureError {
    code: ErrorCode;
    constructor(message?: string);
}

declare class FlagNotFoundError extends OpenFeatureError {
    code: ErrorCode;
    constructor(message?: string);
}

declare class ParseError extends OpenFeatureError {
    code: ErrorCode;
    constructor(message?: string);
}

declare class TypeMismatchError extends OpenFeatureError {
    code: ErrorCode;
    constructor(message?: string);
}

declare class TargetingKeyMissingError extends OpenFeatureError {
    code: ErrorCode;
    constructor(message?: string);
}

declare class InvalidContextError extends OpenFeatureError {
    code: ErrorCode;
    constructor(message?: string);
}

/**
 * Transaction context is a mechanism for adding transaction specific context that
 * is merged with evaluation context prior to flag evaluation. Examples of potential
 * transaction specific context include: a user id, user agent, or request path.
 */
type TransactionContext = EvaluationContext;
interface ManageTransactionContextPropagator<T> extends TransactionContextPropagator {
    /**
     * EXPERIMENTAL: Transaction context propagation is experimental and subject to change.
     * The OpenFeature Enhancement Proposal regarding transaction context can be found [here](https://github.com/open-feature/ofep/pull/32).
     *
     * Sets a transaction context propagator on this receiver. The transaction context
     * propagator is responsible for persisting context for the duration of a single
     * transaction.
     * @experimental
     * @template T The type of the receiver
     * @param {TransactionContextPropagator} transactionContextPropagator The context propagator to be used
     * @returns {T} The receiver (this object)
     */
    setTransactionContextPropagator(transactionContextPropagator: TransactionContextPropagator): T;
}
interface TransactionContextPropagator {
    /**
     * EXPERIMENTAL: Transaction context propagation is experimental and subject to change.
     * The OpenFeature Enhancement Proposal regarding transaction context can be found [here](https://github.com/open-feature/ofep/pull/32).
     *
     * Returns the currently defined transaction context using the registered transaction
     * context propagator.
     * @experimental
     * @returns {TransactionContext} The current transaction context
     */
    getTransactionContext(): TransactionContext;
    /**
     * EXPERIMENTAL: Transaction context propagation is experimental and subject to change.
     * The OpenFeature Enhancement Proposal regarding transaction context can be found [here](https://github.com/open-feature/ofep/pull/32).
     *
     * Sets the transaction context using the registered transaction context propagator.
     * @experimental
     * @template R The return value of the callback
     * @param {TransactionContext} transactionContext The transaction specific context
     * @param {(...args: unknown[]) => R} callback Callback function used to set the transaction context on the stack
     * @param {...unknown[]} args Optional arguments that are passed to the callback function
     */
    setTransactionContext<R>(transactionContext: TransactionContext, callback: (...args: unknown[]) => R, ...args: unknown[]): void;
}

declare class NoopTransactionContextPropagator implements TransactionContextPropagator {
    getTransactionContext(): EvaluationContext;
    setTransactionContext(_: EvaluationContext, callback: () => void): void;
}
declare const NOOP_TRANSACTION_CONTEXT_PROPAGATOR: NoopTransactionContextPropagator;

/**
 * Checks whether the parameter is a string.
 * @param {unknown} value The value to check
 * @returns {value is string} True if the value is a string
 */
declare function isString(value: unknown): value is string;
/**
 * Returns the parameter if it is a string, otherwise returns undefined.
 * @param {unknown} value The value to check
 * @returns {string|undefined} The parameter if it is a string, otherwise undefined
 */
declare function stringOrUndefined(value: unknown): string | undefined;
/**
 * Checks whether the parameter is an object.
 * @param {unknown} value The value to check
 * @returns {value is string} True if the value is an object
 */
declare function isObject<T extends object>(value: unknown): value is T;
/**
 * Returns the parameter if it is an object, otherwise returns undefined.
 * @param {unknown} value The value to check
 * @returns {object|undefined} The parameter if it is an object, otherwise undefined
 */
declare function objectOrUndefined<T extends object>(value: unknown): T | undefined;

declare abstract class OpenFeatureCommonAPI<P extends CommonProvider = CommonProvider> implements Eventing, EvaluationLifeCycle<OpenFeatureCommonAPI<P>>, ManageLogger<OpenFeatureCommonAPI<P>>, ManageTransactionContextPropagator<OpenFeatureCommonAPI<P>> {
    protected _hooks: Hook[];
    protected _transactionContextPropagator: TransactionContextPropagator;
    protected _context: EvaluationContext;
    protected _logger: Logger;
    protected abstract _defaultProvider: P;
    private readonly _events;
    private readonly _clientEventHandlers;
    protected _clientProviders: Map<string, P>;
    protected _clientEvents: Map<string | undefined, InternalEventEmitter>;
    protected _runsOn: Paradigm;
    constructor(category: Paradigm);
    addHooks(...hooks: Hook<FlagValue>[]): this;
    getHooks(): Hook<FlagValue>[];
    clearHooks(): this;
    setLogger(logger: Logger): this;
    /**
     * Get metadata about registered provider.
     * @returns {ProviderMetadata} Provider Metadata
     */
    get providerMetadata(): ProviderMetadata;
    /**
     * Adds a handler for the given provider event type.
     * The handlers are called in the order they have been added.
     * API (global) events run for all providers.
     * @param {ProviderEvents} eventType The provider event type to listen to
     * @param {EventHandler} handler The handler to run on occurrence of the event type
     */
    addHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void;
    /**
     * Removes a handler for the given provider event type.
     * @param {ProviderEvents} eventType The provider event type to remove the listener for
     * @param {EventHandler} handler The handler to remove for the provider event type
     */
    removeHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void;
    /**
     * Gets the current handlers for the given provider event type.
     * @param {ProviderEvents} eventType The provider event type to get the current handlers for
     * @returns {EventHandler[]} The handlers currently attached to the given provider event type
     */
    getHandlers<T extends ProviderEvents>(eventType: T): EventHandler<T>[];
    /**
     * Sets the default provider for flag evaluations and returns a promise that resolves when the provider is ready.
     * This provider will be used by unnamed clients and named clients to which no provider is bound.
     * Setting a provider supersedes the current provider used in new and existing clients without a name.
     * @template P
     * @param {P} provider The provider responsible for flag evaluations.
     * @returns {Promise<void>}
     * @throws Uncaught exceptions thrown by the provider during initialization.
     */
    setProviderAndWait(provider: P): Promise<void>;
    /**
     * Sets the provider that OpenFeature will use for flag evaluations of providers with the given name.
     * A promise is returned that resolves when the provider is ready.
     * Setting a provider supersedes the current provider used in new and existing clients with that name.
     * @template P
     * @param {string} clientName The name to identify the client
     * @param {P} provider The provider responsible for flag evaluations.
     * @returns {Promise<void>}
     * @throws Uncaught exceptions thrown by the provider during initialization.
     */
    setProviderAndWait(clientName: string, provider: P): Promise<void>;
    /**
     * Sets the default provider for flag evaluations.
     * This provider will be used by unnamed clients and named clients to which no provider is bound.
     * Setting a provider supersedes the current provider used in new and existing clients without a name.
     * @template P
     * @param {P} provider The provider responsible for flag evaluations.
     * @returns {this} OpenFeature API
     */
    setProvider(provider: P): this;
    /**
     * Sets the provider that OpenFeature will use for flag evaluations of providers with the given name.
     * Setting a provider supersedes the current provider used in new and existing clients with that name.
     * @template P
     * @param {string} clientName The name to identify the client
     * @param {P} provider The provider responsible for flag evaluations.
     * @returns {this} OpenFeature API
     */
    setProvider(clientName: string, provider: P): this;
    private setAwaitableProvider;
    protected getProviderForClient(name?: string): P;
    protected buildAndCacheEventEmitterForClient(name?: string): InternalEventEmitter;
    private getUnboundEmitters;
    private getAssociatedEventEmitters;
    private transferListeners;
    close(): Promise<void>;
    private handleShutdownError;
    setTransactionContextPropagator(transactionContextPropagator: TransactionContextPropagator): OpenFeatureCommonAPI<P>;
    setTransactionContext<R>(transactionContext: TransactionContext, callback: (...args: unknown[]) => R, ...args: unknown[]): void;
    getTransactionContext(): TransactionContext;
}

interface FlagEvaluationOptions {
    hooks?: Hook[];
    hookHints?: HookHints;
}
interface Features {
    /**
     * Performs a flag evaluation that returns a boolean.
     * @param {string} flagKey The flag key uniquely identifies a particular flag
     * @param {boolean} defaultValue The value returned if an error occurs
     * @param {EvaluationContext} context The evaluation context used on an individual flag evaluation
     * @param {FlagEvaluationOptions} options Additional flag evaluation options
     * @returns {Promise<boolean>} Flag evaluation response
     */
    getBooleanValue(flagKey: string, defaultValue: boolean, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<boolean>;
    /**
     * Performs a flag evaluation that a returns an evaluation details object.
     * @param {string} flagKey The flag key uniquely identifies a particular flag
     * @param {boolean} defaultValue The value returned if an error occurs
     * @param {EvaluationContext} context The evaluation context used on an individual flag evaluation
     * @param {FlagEvaluationOptions} options Additional flag evaluation options
     * @returns {Promise<EvaluationDetails<boolean>>} Flag evaluation details response
     */
    getBooleanDetails(flagKey: string, defaultValue: boolean, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<boolean>>;
    /**
     * Performs a flag evaluation that returns a string.
     * @param {string} flagKey The flag key uniquely identifies a particular flag
     * @template {string} T A optional generic argument constraining the string
     * @param {T} defaultValue The value returned if an error occurs
     * @param {EvaluationContext} context The evaluation context used on an individual flag evaluation
     * @param {FlagEvaluationOptions} options Additional flag evaluation options
     * @returns {Promise<T>} Flag evaluation response
     */
    getStringValue(flagKey: string, defaultValue: string, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<string>;
    getStringValue<T extends string = string>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<T>;
    /**
     * Performs a flag evaluation that a returns an evaluation details object.
     * @param {string} flagKey The flag key uniquely identifies a particular flag
     * @template {string} T A optional generic argument constraining the string
     * @param {T} defaultValue The value returned if an error occurs
     * @param {EvaluationContext} context The evaluation context used on an individual flag evaluation
     * @param {FlagEvaluationOptions} options Additional flag evaluation options
     * @returns {Promise<EvaluationDetails<T>>} Flag evaluation details response
     */
    getStringDetails(flagKey: string, defaultValue: string, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<string>>;
    getStringDetails<T extends string = string>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<T>>;
    /**
     * Performs a flag evaluation that returns a number.
     * @param {string} flagKey The flag key uniquely identifies a particular flag
     * @template {number} T A optional generic argument constraining the number
     * @param {T} defaultValue The value returned if an error occurs
     * @param {EvaluationContext} context The evaluation context used on an individual flag evaluation
     * @param {FlagEvaluationOptions} options Additional flag evaluation options
     * @returns {Promise<T>} Flag evaluation response
     */
    getNumberValue(flagKey: string, defaultValue: number, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<number>;
    getNumberValue<T extends number = number>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<T>;
    /**
     * Performs a flag evaluation that a returns an evaluation details object.
     * @param {string} flagKey The flag key uniquely identifies a particular flag
     * @template {number} T A optional generic argument constraining the number
     * @param {T} defaultValue The value returned if an error occurs
     * @param {EvaluationContext} context The evaluation context used on an individual flag evaluation
     * @param {FlagEvaluationOptions} options Additional flag evaluation options
     * @returns {Promise<EvaluationDetails<T>>} Flag evaluation details response
     */
    getNumberDetails(flagKey: string, defaultValue: number, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<number>>;
    getNumberDetails<T extends number = number>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<T>>;
    /**
     * Performs a flag evaluation that returns an object.
     * @param {string} flagKey The flag key uniquely identifies a particular flag
     * @template {JsonValue} T A optional generic argument describing the structure
     * @param {T} defaultValue The value returned if an error occurs
     * @param {EvaluationContext} context The evaluation context used on an individual flag evaluation
     * @param {FlagEvaluationOptions} options Additional flag evaluation options
     * @returns {Promise<T>} Flag evaluation response
     */
    getObjectValue(flagKey: string, defaultValue: JsonValue, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<JsonValue>;
    getObjectValue<T extends JsonValue = JsonValue>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<T>;
    /**
     * Performs a flag evaluation that a returns an evaluation details object.
     * @param {string} flagKey The flag key uniquely identifies a particular flag
     * @template {JsonValue} T A optional generic argument describing the structure
     * @param {T} defaultValue The value returned if an error occurs
     * @param {EvaluationContext} context The evaluation context used on an individual flag evaluation
     * @param {FlagEvaluationOptions} options Additional flag evaluation options
     * @returns {Promise<EvaluationDetails<T>>} Flag evaluation details response
     */
    getObjectDetails(flagKey: string, defaultValue: JsonValue, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<JsonValue>>;
    getObjectDetails<T extends JsonValue = JsonValue>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<T>>;
}

interface Client extends EvaluationLifeCycle<Client>, Features, ManageContext<Client>, ManageLogger<Client>, Eventing {
    readonly metadata: ClientMetadata;
}

/**
 * Interface that providers must implement to resolve flag values for their particular
 * backend or vendor.
 *
 * Implementation for resolving all the required flag types must be defined.
 */
interface Provider extends CommonProvider {
    /**
     * A provider hook exposes a mechanism for provider authors to register hooks
     * to tap into various stages of the flag evaluation lifecycle. These hooks can
     * be used to perform side effects and mutate the context for purposes of the
     * provider. Provider hooks are not configured or controlled by the application author.
     */
    readonly hooks?: Hook[];
    /**
     * Resolve a boolean flag and its evaluation details.
     */
    resolveBooleanEvaluation(flagKey: string, defaultValue: boolean, context: EvaluationContext, logger: Logger): Promise<ResolutionDetails<boolean>>;
    /**
     * Resolve a string flag and its evaluation details.
     */
    resolveStringEvaluation(flagKey: string, defaultValue: string, context: EvaluationContext, logger: Logger): Promise<ResolutionDetails<string>>;
    /**
     * Resolve a numeric flag and its evaluation details.
     */
    resolveNumberEvaluation(flagKey: string, defaultValue: number, context: EvaluationContext, logger: Logger): Promise<ResolutionDetails<number>>;
    /**
     * Resolve and parse an object flag and its evaluation details.
     */
    resolveObjectEvaluation<T extends JsonValue>(flagKey: string, defaultValue: T, context: EvaluationContext, logger: Logger): Promise<ResolutionDetails<T>>;
}

/**
 * The No-op provider is set by default, and simply always returns the default value.
 */
declare class NoopFeatureProvider implements Provider {
    readonly metadata: {
        readonly name: "No-op Provider";
    };
    get status(): ProviderStatus;
    resolveBooleanEvaluation(_: string, defaultValue: boolean): Promise<ResolutionDetails<boolean>>;
    resolveStringEvaluation(_: string, defaultValue: string): Promise<ResolutionDetails<string>>;
    resolveNumberEvaluation(_: string, defaultValue: number): Promise<ResolutionDetails<number>>;
    resolveObjectEvaluation<T extends JsonValue>(_: string, defaultValue: T): Promise<ResolutionDetails<T>>;
    private noOp;
}
declare const NOOP_PROVIDER: NoopFeatureProvider;

/**
 * Don't export types from this file publicly.
 * It might cause confusion since these types are not a part of the general API,
 * but just for the in-memory provider.
 */

type Variants<T> = Record<string, T>;
/**
 * A Feature Flag definition, containing it's specification
 */
type Flag = {
    /**
     * An object containing all possible flags mappings (variant -> flag value)
     */
    variants: Variants<boolean> | Variants<string> | Variants<number> | Variants<JsonValue>;
    /**
     * The variant it will resolve to in STATIC evaluation
     */
    defaultVariant: string;
    /**
     * Determines if flag evaluation is enabled or not for this flag.
     * If false, falls back to the default value provided to the client
     */
    disabled: boolean;
    /**
     * Function used in order to evaluate a flag to a specific value given the provided context.
     * It should return a variant key.
     * If it does not return a valid variant it falls back to the default value provided to the client
     * @param EvaluationContext
     */
    contextEvaluator?: (ctx: EvaluationContext) => string;
};
type FlagConfiguration = Record<string, Flag>;

/**
 * A simple OpenFeature provider intended for demos and as a test stub.
 */
declare class InMemoryProvider implements Provider {
    readonly events: OpenFeatureEventEmitter;
    readonly runsOn = "server";
    readonly metadata: {
        readonly name: "in-memory";
    };
    private _flagConfiguration;
    constructor(flagConfiguration?: FlagConfiguration);
    /**
     * Overwrites the configured flags.
     * @param { FlagConfiguration } flagConfiguration new flag configuration
     */
    putConfiguration(flagConfiguration: FlagConfiguration): void;
    resolveBooleanEvaluation(flagKey: string, defaultValue: boolean, context?: EvaluationContext, logger?: Logger): Promise<ResolutionDetails<boolean>>;
    resolveNumberEvaluation(flagKey: string, defaultValue: number, context?: EvaluationContext, logger?: Logger): Promise<ResolutionDetails<number>>;
    resolveStringEvaluation(flagKey: string, defaultValue: string, context?: EvaluationContext, logger?: Logger): Promise<ResolutionDetails<string>>;
    resolveObjectEvaluation<T extends JsonValue>(flagKey: string, defaultValue: T, context?: EvaluationContext, logger?: Logger): Promise<ResolutionDetails<T>>;
    private resolveFlagWithReason;
    private lookupFlagValue;
}

type OpenFeatureClientOptions = {
    name?: string;
    version?: string;
};
declare class OpenFeatureClient implements Client, ManageContext<OpenFeatureClient> {
    private readonly providerAccessor;
    private readonly emitterAccessor;
    private readonly globalLogger;
    private readonly options;
    private _context;
    private _hooks;
    private _clientLogger?;
    constructor(providerAccessor: () => Provider, emitterAccessor: () => InternalEventEmitter, globalLogger: () => Logger, options: OpenFeatureClientOptions, context?: EvaluationContext);
    get metadata(): ClientMetadata;
    addHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void;
    removeHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void;
    getHandlers(eventType: ProviderEvents): EventHandler<ProviderEvents>[];
    setLogger(logger: Logger): OpenFeatureClient;
    setContext(context: EvaluationContext): OpenFeatureClient;
    getContext(): EvaluationContext;
    addHooks(...hooks: Hook<FlagValue>[]): OpenFeatureClient;
    getHooks(): Hook<FlagValue>[];
    clearHooks(): OpenFeatureClient;
    getBooleanValue(flagKey: string, defaultValue: boolean, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<boolean>;
    getBooleanDetails(flagKey: string, defaultValue: boolean, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<boolean>>;
    getStringValue<T extends string = string>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<T>;
    getStringDetails<T extends string = string>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<T>>;
    getNumberValue<T extends number = number>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<T>;
    getNumberDetails<T extends number = number>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<T>>;
    getObjectValue<T extends JsonValue = JsonValue>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<T>;
    getObjectDetails<T extends JsonValue = JsonValue>(flagKey: string, defaultValue: T, context?: EvaluationContext, options?: FlagEvaluationOptions): Promise<EvaluationDetails<T>>;
    private evaluate;
    private beforeHooks;
    private afterHooks;
    private errorHooks;
    private finallyHooks;
    private get _provider();
    private get _logger();
}

declare class OpenFeatureAPI extends OpenFeatureCommonAPI<Provider> implements ManageContext<OpenFeatureAPI> {
    protected _defaultProvider: Provider;
    private constructor();
    /**
     * Gets a singleton instance of the OpenFeature API.
     * @ignore
     * @returns {OpenFeatureAPI} OpenFeature API
     */
    static getInstance(): OpenFeatureAPI;
    setContext(context: EvaluationContext): this;
    getContext(): EvaluationContext;
    /**
     * A factory function for creating new unnamed OpenFeature clients. Clients can contain
     * their own state (e.g. logger, hook, context). Multiple clients can be used
     * to segment feature flag configuration.
     *
     * All unnamed clients use the same provider set via {@link this.setProvider setProvider}.
     * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations
     * @returns {Client} OpenFeature Client
     */
    getClient(context?: EvaluationContext): Client;
    /**
     * A factory function for creating new named OpenFeature clients. Clients can contain
     * their own state (e.g. logger, hook, context). Multiple clients can be used
     * to segment feature flag configuration.
     *
     * If there is already a provider bound to this name via {@link this.setProvider setProvider}, this provider will be used.
     * Otherwise, the default provider is used until a provider is assigned to that name.
     * @param {string} name The name of the client
     * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations
     * @returns {Client} OpenFeature Client
     */
    getClient(name: string, context?: EvaluationContext): Client;
    /**
     * A factory function for creating new named OpenFeature clients. Clients can contain
     * their own state (e.g. logger, hook, context). Multiple clients can be used
     * to segment feature flag configuration.
     *
     * If there is already a provider bound to this name via {@link this.setProvider setProvider}, this provider will be used.
     * Otherwise, the default provider is used until a provider is assigned to that name.
     * @param {string} name The name of the client
     * @param {string} version The version of the client (only used for metadata)
     * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations
     * @returns {Client} OpenFeature Client
     */
    getClient(name: string, version: string, context?: EvaluationContext): Client;
}
/**
 * A singleton instance of the OpenFeature API.
 * @returns {OpenFeatureAPI} OpenFeature API
 */
declare const OpenFeature: OpenFeatureAPI;

export { BeforeHookContext, Client, ClientMetadata, CommonEventDetails, CommonProvider, ConfigChangeEvent, DefaultLogger, ErrorCode, ErrorEvent, EvaluationContext, EvaluationContextValue, EvaluationDetails, EvaluationLifeCycle, EventContext, EventDetails, EventHandler, EventMetadata, Eventing, Features, FlagEvaluationOptions, FlagMetadata, FlagNotFoundError, FlagValue, FlagValueType, GeneralError, Hook, HookContext, HookHints, InMemoryProvider, InternalEventEmitter, InvalidContextError, JsonArray, JsonObject, JsonValue, LOG_LEVELS, Logger, ManageContext, ManageLogger, ManageTransactionContextPropagator, Metadata, NOOP_PROVIDER, NOOP_TRANSACTION_CONTEXT_PROPAGATOR, OpenFeature, OpenFeatureAPI, OpenFeatureClient, OpenFeatureCommonAPI, OpenFeatureError, OpenFeatureEventEmitter, Paradigm, ParseError, PrimitiveValue, Provider, ProviderEvents, ProviderMetadata, ProviderStatus, ReadyEvent, ResolutionDetails, ResolutionReason, SafeLogger, StaleEvent, StandardResolutionReasons, TargetingKeyMissingError, TransactionContext, TransactionContextPropagator, TypeMismatchError, isObject, isString, objectOrUndefined, statusMatchesEvent, stringOrUndefined };
