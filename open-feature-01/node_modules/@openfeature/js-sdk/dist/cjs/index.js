"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DefaultLogger: () => DefaultLogger,
  ErrorCode: () => ErrorCode,
  FlagNotFoundError: () => FlagNotFoundError,
  GeneralError: () => GeneralError,
  InMemoryProvider: () => InMemoryProvider,
  InternalEventEmitter: () => InternalEventEmitter,
  InvalidContextError: () => InvalidContextError,
  LOG_LEVELS: () => LOG_LEVELS,
  NOOP_PROVIDER: () => NOOP_PROVIDER,
  NOOP_TRANSACTION_CONTEXT_PROPAGATOR: () => NOOP_TRANSACTION_CONTEXT_PROPAGATOR,
  OpenFeature: () => OpenFeature,
  OpenFeatureAPI: () => OpenFeatureAPI,
  OpenFeatureClient: () => OpenFeatureClient,
  OpenFeatureCommonAPI: () => OpenFeatureCommonAPI,
  OpenFeatureError: () => OpenFeatureError,
  OpenFeatureEventEmitter: () => OpenFeatureEventEmitter,
  ParseError: () => ParseError,
  ProviderEvents: () => ProviderEvents,
  ProviderStatus: () => ProviderStatus,
  SafeLogger: () => SafeLogger,
  StandardResolutionReasons: () => StandardResolutionReasons,
  TargetingKeyMissingError: () => TargetingKeyMissingError,
  TypeMismatchError: () => TypeMismatchError,
  isObject: () => isObject,
  isString: () => isString,
  objectOrUndefined: () => objectOrUndefined,
  statusMatchesEvent: () => statusMatchesEvent,
  stringOrUndefined: () => stringOrUndefined
});
module.exports = __toCommonJS(src_exports);

// ../shared/src/errors/open-feature-error-abstract.ts
var OpenFeatureError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, OpenFeatureError.prototype);
    this.name = "OpenFeatureError";
  }
};

// ../shared/src/evaluation/evaluation.ts
var StandardResolutionReasons = {
  /**
   * The resolved value was the result of a dynamic evaluation, such as a rule or specific user-targeting.
   */
  TARGETING_MATCH: "TARGETING_MATCH",
  /**
   * The resolved value was the result of pseudorandom assignment.
   */
  SPLIT: "SPLIT",
  /**
   * The resolved value was the result of the flag being disabled in the management system.
   */
  DISABLED: "DISABLED",
  /**
   *  The resolved value was configured statically, or otherwise fell back to a pre-configured value.
   */
  DEFAULT: "DEFAULT",
  /**
   * The reason for the resolved value could not be determined.
   */
  UNKNOWN: "UNKNOWN",
  /**
   * The resolved value is static (no dynamic evaluation).
   */
  STATIC: "STATIC",
  /**
   * The resolved value was retrieved from cache.
   */
  CACHED: "CACHED",
  /**
   * The resolved value was the result of an error.
   *
   * Note: The `errorCode` and `errorMessage` fields may contain additional details of this error.
   */
  ERROR: "ERROR"
};
var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["PROVIDER_NOT_READY"] = "PROVIDER_NOT_READY";
  ErrorCode2["FLAG_NOT_FOUND"] = "FLAG_NOT_FOUND";
  ErrorCode2["PARSE_ERROR"] = "PARSE_ERROR";
  ErrorCode2["TYPE_MISMATCH"] = "TYPE_MISMATCH";
  ErrorCode2["TARGETING_KEY_MISSING"] = "TARGETING_KEY_MISSING";
  ErrorCode2["INVALID_CONTEXT"] = "INVALID_CONTEXT";
  ErrorCode2["GENERAL"] = "GENERAL";
  return ErrorCode2;
})(ErrorCode || {});

// ../shared/src/errors/general-error.ts
var GeneralError = class extends OpenFeatureError {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, GeneralError.prototype);
    this.name = "GeneralError";
    this.code = "GENERAL" /* GENERAL */;
  }
};

// ../shared/src/errors/flag-not-found-error.ts
var FlagNotFoundError = class extends OpenFeatureError {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, FlagNotFoundError.prototype);
    this.name = "FlagNotFoundError";
    this.code = "FLAG_NOT_FOUND" /* FLAG_NOT_FOUND */;
  }
};

// ../shared/src/errors/parse-error.ts
var ParseError = class extends OpenFeatureError {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, ParseError.prototype);
    this.name = "ParseError";
    this.code = "PARSE_ERROR" /* PARSE_ERROR */;
  }
};

// ../shared/src/errors/type-mismatch-error.ts
var TypeMismatchError = class extends OpenFeatureError {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, TypeMismatchError.prototype);
    this.name = "TypeMismatchError";
    this.code = "TYPE_MISMATCH" /* TYPE_MISMATCH */;
  }
};

// ../shared/src/errors/targeting-key-missing-error.ts
var TargetingKeyMissingError = class extends OpenFeatureError {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, TargetingKeyMissingError.prototype);
    this.name = "TargetingKeyMissingError";
    this.code = "TARGETING_KEY_MISSING" /* TARGETING_KEY_MISSING */;
  }
};

// ../shared/src/errors/invalid-context-error.ts
var InvalidContextError = class extends OpenFeatureError {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, InvalidContextError.prototype);
    this.name = "InvalidContextError";
    this.code = "INVALID_CONTEXT" /* INVALID_CONTEXT */;
  }
};

// ../shared/src/provider/provider.ts
var ProviderStatus = /* @__PURE__ */ ((ProviderStatus2) => {
  ProviderStatus2["NOT_READY"] = "NOT_READY";
  ProviderStatus2["READY"] = "READY";
  ProviderStatus2["ERROR"] = "ERROR";
  ProviderStatus2["STALE"] = "STALE";
  return ProviderStatus2;
})(ProviderStatus || {});

// ../shared/src/events/events.ts
var ProviderEvents = /* @__PURE__ */ ((ProviderEvents3) => {
  ProviderEvents3["Ready"] = "PROVIDER_READY";
  ProviderEvents3["Error"] = "PROVIDER_ERROR";
  ProviderEvents3["ConfigurationChanged"] = "PROVIDER_CONFIGURATION_CHANGED";
  ProviderEvents3["Stale"] = "PROVIDER_STALE";
  return ProviderEvents3;
})(ProviderEvents || {});

// ../shared/src/events/event-utils.ts
var eventStatusMap = {
  ["READY" /* READY */]: "PROVIDER_READY" /* Ready */,
  ["ERROR" /* ERROR */]: "PROVIDER_ERROR" /* Error */,
  ["STALE" /* STALE */]: "PROVIDER_STALE" /* Stale */,
  ["NOT_READY" /* NOT_READY */]: void 0
};
var statusMatchesEvent = (event, status) => {
  return !status && event === "PROVIDER_READY" /* Ready */ || eventStatusMap[status] === event;
};

// ../shared/src/events/open-feature-event-emitter.ts
var import_events2 = __toESM(require("events"));

// ../shared/src/logger/default-logger.ts
var DefaultLogger = class {
  error(...args) {
    console.error(...args);
  }
  warn(...args) {
    console.warn(...args);
  }
  info() {
  }
  debug() {
  }
};

// ../shared/src/logger/safe-logger.ts
var LOG_LEVELS = ["error", "warn", "info", "debug"];
var SafeLogger = class {
  constructor(logger) {
    this.fallbackLogger = new DefaultLogger();
    try {
      for (const level of LOG_LEVELS) {
        if (!logger[level] || typeof logger[level] !== "function") {
          throw new Error(`The provided logger is missing the ${level} method.`);
        }
      }
      this.logger = logger;
    } catch (err) {
      console.error(err);
      console.error("Falling back to the default logger.");
      this.logger = this.fallbackLogger;
    }
  }
  error(...args) {
    this.log("error", ...args);
  }
  warn(...args) {
    this.log("warn", ...args);
  }
  info(...args) {
    this.log("info", ...args);
  }
  debug(...args) {
    this.log("debug", ...args);
  }
  log(level, ...args) {
    try {
      this.logger[level](...args);
    } catch (error) {
      this.fallbackLogger[level](...args);
    }
  }
};

// ../shared/src/events/open-feature-event-emitter.ts
var GenericEventEmitter = class {
  constructor(globalLogger) {
    this.globalLogger = globalLogger;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this._handlers = /* @__PURE__ */ new WeakMap();
    this.eventEmitter = new import_events2.default({ captureRejections: true });
    this.eventEmitter.on("error", (err) => {
      var _a;
      (_a = this._logger) == null ? void 0 : _a.error("Error running event handler:", err);
    });
  }
  emit(eventType, context) {
    this.eventEmitter.emit(eventType, context);
  }
  addHandler(eventType, handler) {
    const asyncHandler = (details) => __async(this, null, function* () {
      yield handler(details);
    });
    this._handlers.set(handler, asyncHandler);
    this.eventEmitter.on(eventType, asyncHandler);
  }
  removeHandler(eventType, handler) {
    const asyncHandler = this._handlers.get(handler);
    if (!asyncHandler) {
      return;
    }
    this.eventEmitter.removeListener(eventType, asyncHandler);
  }
  removeAllHandlers(eventType) {
    if (eventType) {
      this.eventEmitter.removeAllListeners(eventType);
    } else {
      this.eventEmitter.removeAllListeners();
    }
  }
  getHandlers(eventType) {
    return this.eventEmitter.listeners(eventType);
  }
  setLogger(logger) {
    this._eventLogger = new SafeLogger(logger);
    return this;
  }
  get _logger() {
    var _a, _b;
    return (_b = this._eventLogger) != null ? _b : (_a = this.globalLogger) == null ? void 0 : _a.call(this);
  }
};
var OpenFeatureEventEmitter = class extends GenericEventEmitter {
};
var InternalEventEmitter = class extends GenericEventEmitter {
};

// ../shared/src/transaction-context/no-op-transaction-context-propagator.ts
var NoopTransactionContextPropagator = class {
  getTransactionContext() {
    return {};
  }
  setTransactionContext(_, callback) {
    callback();
  }
};
var NOOP_TRANSACTION_CONTEXT_PROPAGATOR = new NoopTransactionContextPropagator();

// ../shared/src/type-guards.ts
function isString(value) {
  return typeof value === "string";
}
function stringOrUndefined(value) {
  return isString(value) ? value : void 0;
}
function isObject(value) {
  return typeof value === "object";
}
function objectOrUndefined(value) {
  return isObject(value) ? value : void 0;
}

// ../shared/src/filter.ts
function isDefined(input) {
  return typeof input !== "undefined" && input !== null;
}

// ../shared/src/open-feature.ts
var OpenFeatureCommonAPI = class {
  constructor(category) {
    this._hooks = [];
    this._transactionContextPropagator = NOOP_TRANSACTION_CONTEXT_PROPAGATOR;
    this._context = {};
    this._logger = new DefaultLogger();
    this._events = new InternalEventEmitter(() => this._logger);
    this._clientEventHandlers = /* @__PURE__ */ new Map();
    this._clientProviders = /* @__PURE__ */ new Map();
    this._clientEvents = /* @__PURE__ */ new Map();
    this._runsOn = category;
  }
  addHooks(...hooks) {
    this._hooks = [...this._hooks, ...hooks];
    return this;
  }
  getHooks() {
    return this._hooks;
  }
  clearHooks() {
    this._hooks = [];
    return this;
  }
  setLogger(logger) {
    this._logger = new SafeLogger(logger);
    return this;
  }
  /**
   * Get metadata about registered provider.
   * @returns {ProviderMetadata} Provider Metadata
   */
  get providerMetadata() {
    return this._defaultProvider.metadata;
  }
  /**
   * Adds a handler for the given provider event type.
   * The handlers are called in the order they have been added.
   * API (global) events run for all providers.
   * @param {ProviderEvents} eventType The provider event type to listen to
   * @param {EventHandler} handler The handler to run on occurrence of the event type
   */
  addHandler(eventType, handler) {
    [.../* @__PURE__ */ new Map([[void 0, this._defaultProvider]]), ...this._clientProviders].forEach((keyProviderTuple) => {
      var _a;
      const clientName = keyProviderTuple[0];
      const provider = keyProviderTuple[1];
      const shouldRunNow = statusMatchesEvent(eventType, keyProviderTuple[1].status);
      if (shouldRunNow) {
        try {
          handler({ clientName, providerName: provider.metadata.name });
        } catch (err) {
          (_a = this._logger) == null ? void 0 : _a.error("Error running event handler:", err);
        }
      }
    });
    this._events.addHandler(eventType, handler);
  }
  /**
   * Removes a handler for the given provider event type.
   * @param {ProviderEvents} eventType The provider event type to remove the listener for
   * @param {EventHandler} handler The handler to remove for the provider event type
   */
  removeHandler(eventType, handler) {
    this._events.removeHandler(eventType, handler);
  }
  /**
   * Gets the current handlers for the given provider event type.
   * @param {ProviderEvents} eventType The provider event type to get the current handlers for
   * @returns {EventHandler[]} The handlers currently attached to the given provider event type
   */
  getHandlers(eventType) {
    return this._events.getHandlers(eventType);
  }
  setProviderAndWait(clientOrProvider, providerOrUndefined) {
    return __async(this, null, function* () {
      yield this.setAwaitableProvider(clientOrProvider, providerOrUndefined);
    });
  }
  setProvider(clientOrProvider, providerOrUndefined) {
    const maybePromise = this.setAwaitableProvider(clientOrProvider, providerOrUndefined);
    if (maybePromise) {
      maybePromise.catch(() => {
      });
    }
    return this;
  }
  setAwaitableProvider(clientOrProvider, providerOrUndefined) {
    var _a, _b, _c, _d, _e, _f;
    const clientName = stringOrUndefined(clientOrProvider);
    const provider = (_a = objectOrUndefined(clientOrProvider)) != null ? _a : objectOrUndefined(providerOrUndefined);
    if (!provider) {
      this._logger.debug("No provider defined, ignoring setProvider call");
      return;
    }
    const oldProvider = this.getProviderForClient(clientName);
    const providerName = provider.metadata.name;
    if (oldProvider === provider) {
      this._logger.debug("Provider is already set, ignoring setProvider call");
      return;
    }
    if (!provider.runsOn) {
      this._logger.debug(`Provider '${provider.metadata.name}' has not defined its intended use.`);
    } else if (provider.runsOn !== this._runsOn) {
      throw new GeneralError(`Provider '${provider.metadata.name}' is intended for use on the ${provider.runsOn}.`);
    }
    const emitters = this.getAssociatedEventEmitters(clientName);
    if (typeof provider.initialize === "function" && provider.status === void 0) {
      const activeLogger = this._logger || console;
      activeLogger.warn(
        `Provider ${providerName} implements 'initialize' but not 'status'. Please implement 'status'.`
      );
    }
    let initializationPromise = void 0;
    if ((provider == null ? void 0 : provider.status) === "NOT_READY" /* NOT_READY */ && typeof provider.initialize === "function") {
      initializationPromise = (_d = (_c = (_b = provider.initialize) == null ? void 0 : _b.call(provider, this._context)) == null ? void 0 : _c.then(() => {
        var _a2;
        this.getAssociatedEventEmitters(clientName).forEach((emitter) => {
          emitter == null ? void 0 : emitter.emit("PROVIDER_READY" /* Ready */, { clientName, providerName });
        });
        (_a2 = this._events) == null ? void 0 : _a2.emit("PROVIDER_READY" /* Ready */, { clientName, providerName });
      })) == null ? void 0 : _d.catch((error) => {
        var _a2;
        this.getAssociatedEventEmitters(clientName).forEach((emitter) => {
          emitter == null ? void 0 : emitter.emit("PROVIDER_ERROR" /* Error */, { clientName, providerName, message: error.message });
        });
        (_a2 = this._events) == null ? void 0 : _a2.emit("PROVIDER_ERROR" /* Error */, { clientName, providerName, message: error.message });
        throw error;
      });
    } else {
      emitters.forEach((emitter) => {
        emitter == null ? void 0 : emitter.emit("PROVIDER_READY" /* Ready */, { clientName, providerName });
      });
      (_e = this._events) == null ? void 0 : _e.emit("PROVIDER_READY" /* Ready */, { clientName, providerName });
    }
    if (clientName) {
      this._clientProviders.set(clientName, provider);
    } else {
      this._defaultProvider = provider;
    }
    this.transferListeners(oldProvider, provider, clientName, emitters);
    if (![...this._clientProviders.values(), this._defaultProvider].includes(oldProvider)) {
      (_f = oldProvider == null ? void 0 : oldProvider.onClose) == null ? void 0 : _f.call(oldProvider);
    }
    return initializationPromise;
  }
  getProviderForClient(name) {
    var _a;
    if (!name) {
      return this._defaultProvider;
    }
    return (_a = this._clientProviders.get(name)) != null ? _a : this._defaultProvider;
  }
  buildAndCacheEventEmitterForClient(name) {
    const emitter = this._clientEvents.get(name);
    if (emitter) {
      return emitter;
    }
    const newEmitter = new InternalEventEmitter(() => this._logger);
    this._clientEvents.set(name, newEmitter);
    const clientProvider = this.getProviderForClient(name);
    Object.values(ProviderEvents).forEach(
      (eventType) => {
        var _a;
        return (_a = clientProvider.events) == null ? void 0 : _a.addHandler(eventType, (details) => __async(this, null, function* () {
          newEmitter.emit(eventType, __spreadProps(__spreadValues({}, details), { clientName: name, providerName: clientProvider.metadata.name }));
        }));
      }
    );
    return newEmitter;
  }
  getUnboundEmitters() {
    const namedProviders = [...this._clientProviders.keys()];
    const eventEmitterNames = [...this._clientEvents.keys()].filter(isDefined);
    const unboundEmitterNames = eventEmitterNames.filter((name) => !namedProviders.includes(name));
    return [
      // all unbound, named emitters
      ...unboundEmitterNames.map((name) => this._clientEvents.get(name)),
      // the default emitter
      this._clientEvents.get(void 0)
    ].filter(isDefined);
  }
  getAssociatedEventEmitters(clientName) {
    return clientName ? [this.buildAndCacheEventEmitterForClient(clientName)] : this.getUnboundEmitters();
  }
  transferListeners(oldProvider, newProvider, clientName, emitters) {
    var _a;
    (_a = this._clientEventHandlers.get(clientName)) == null ? void 0 : _a.forEach((eventHandler) => {
      var _a2;
      return (_a2 = oldProvider.events) == null ? void 0 : _a2.removeHandler(...eventHandler);
    });
    const newClientHandlers = Object.values(ProviderEvents).map((eventType) => {
      const handler = (details) => __async(this, null, function* () {
        emitters.forEach((emitter) => {
          emitter == null ? void 0 : emitter.emit(eventType, __spreadProps(__spreadValues({}, details), { clientName, providerName: newProvider.metadata.name }));
        });
        this._events.emit(eventType, __spreadProps(__spreadValues({}, details), { clientName, providerName: newProvider.metadata.name }));
      });
      return [eventType, handler];
    });
    this._clientEventHandlers.set(clientName, newClientHandlers);
    newClientHandlers.forEach((eventHandler) => {
      var _a2;
      return (_a2 = newProvider.events) == null ? void 0 : _a2.addHandler(...eventHandler);
    });
  }
  close() {
    return __async(this, null, function* () {
      var _a, _b;
      try {
        yield (_b = (_a = this == null ? void 0 : this._defaultProvider) == null ? void 0 : _a.onClose) == null ? void 0 : _b.call(_a);
      } catch (err) {
        this.handleShutdownError(this._defaultProvider, err);
      }
      const providers = Array.from(this._clientProviders);
      yield Promise.all(
        providers.map((_0) => __async(this, [_0], function* ([, provider]) {
          var _a2;
          try {
            yield (_a2 = provider.onClose) == null ? void 0 : _a2.call(provider);
          } catch (err) {
            this.handleShutdownError(this._defaultProvider, err);
          }
        }))
      );
    });
  }
  handleShutdownError(provider, err) {
    this._logger.error(`Error during shutdown of provider ${provider.metadata.name}: ${err}`);
    this._logger.error(err == null ? void 0 : err.stack);
  }
  setTransactionContextPropagator(transactionContextPropagator) {
    const baseMessage = "Invalid TransactionContextPropagator, will not be set: ";
    if (typeof (transactionContextPropagator == null ? void 0 : transactionContextPropagator.getTransactionContext) !== "function") {
      this._logger.error(`${baseMessage}: getTransactionContext is not a function.`);
    } else if (typeof (transactionContextPropagator == null ? void 0 : transactionContextPropagator.setTransactionContext) !== "function") {
      this._logger.error(`${baseMessage}: setTransactionContext is not a function.`);
    } else {
      this._transactionContextPropagator = transactionContextPropagator;
    }
    return this;
  }
  setTransactionContext(transactionContext, callback, ...args) {
    this._transactionContextPropagator.setTransactionContext(transactionContext, callback, ...args);
  }
  getTransactionContext() {
    try {
      return this._transactionContextPropagator.getTransactionContext();
    } catch (err) {
      const error = err;
      this._logger.error(`Error getting transaction context: ${error == null ? void 0 : error.message}, returning empty context.`);
      this._logger.error(error == null ? void 0 : error.stack);
      return {};
    }
  }
};

// src/provider/no-op-provider.ts
var REASON_NO_OP = "No-op";
var NoopFeatureProvider = class {
  constructor() {
    this.metadata = {
      name: "No-op Provider"
    };
  }
  get status() {
    return "NOT_READY" /* NOT_READY */;
  }
  resolveBooleanEvaluation(_, defaultValue) {
    return this.noOp(defaultValue);
  }
  resolveStringEvaluation(_, defaultValue) {
    return this.noOp(defaultValue);
  }
  resolveNumberEvaluation(_, defaultValue) {
    return this.noOp(defaultValue);
  }
  resolveObjectEvaluation(_, defaultValue) {
    return this.noOp(defaultValue);
  }
  noOp(defaultValue) {
    return Promise.resolve({
      value: defaultValue,
      reason: REASON_NO_OP
    });
  }
};
var NOOP_PROVIDER = new NoopFeatureProvider();

// src/provider/in-memory-provider/variant-not-found-error.ts
var VariantFoundError = class extends OpenFeatureError {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, VariantFoundError.prototype);
    this.name = "VariantFoundError";
    this.code = "GENERAL" /* GENERAL */;
  }
};

// src/provider/in-memory-provider/in-memory-provider.ts
var InMemoryProvider = class {
  constructor(flagConfiguration = {}) {
    this.events = new OpenFeatureEventEmitter();
    this.runsOn = "server";
    this.metadata = {
      name: "in-memory"
    };
    this._flagConfiguration = __spreadValues({}, flagConfiguration);
  }
  /**
   * Overwrites the configured flags.
   * @param { FlagConfiguration } flagConfiguration new flag configuration
   */
  putConfiguration(flagConfiguration) {
    const flagsChanged = Object.entries(flagConfiguration).filter(([key, value]) => this._flagConfiguration[key] !== value).map(([key]) => key);
    this._flagConfiguration = __spreadValues({}, flagConfiguration);
    this.events.emit("PROVIDER_CONFIGURATION_CHANGED" /* ConfigurationChanged */, { flagsChanged });
  }
  resolveBooleanEvaluation(flagKey, defaultValue, context, logger) {
    return this.resolveFlagWithReason(flagKey, defaultValue, context, logger);
  }
  resolveNumberEvaluation(flagKey, defaultValue, context, logger) {
    return this.resolveFlagWithReason(flagKey, defaultValue, context, logger);
  }
  resolveStringEvaluation(flagKey, defaultValue, context, logger) {
    return __async(this, null, function* () {
      return this.resolveFlagWithReason(flagKey, defaultValue, context, logger);
    });
  }
  resolveObjectEvaluation(flagKey, defaultValue, context, logger) {
    return __async(this, null, function* () {
      return this.resolveFlagWithReason(flagKey, defaultValue, context, logger);
    });
  }
  resolveFlagWithReason(flagKey, defaultValue, ctx, logger) {
    return __async(this, null, function* () {
      try {
        const resolutionResult = this.lookupFlagValue(flagKey, defaultValue, ctx, logger);
        if (typeof (resolutionResult == null ? void 0 : resolutionResult.value) != typeof defaultValue) {
          throw new TypeMismatchError();
        }
        return resolutionResult;
      } catch (error) {
        if (!(error instanceof OpenFeatureError)) {
          throw new GeneralError((error == null ? void 0 : error.message) || "unknown error");
        }
        throw error;
      }
    });
  }
  lookupFlagValue(flagKey, defaultValue, ctx, logger) {
    var _a;
    if (!(flagKey in this._flagConfiguration)) {
      const message = `no flag found with key ${flagKey}`;
      logger == null ? void 0 : logger.debug(message);
      throw new FlagNotFoundError(message);
    }
    const flagSpec = this._flagConfiguration[flagKey];
    if (flagSpec.disabled) {
      return { value: defaultValue, reason: StandardResolutionReasons.DISABLED };
    }
    const isContextEval = ctx && (flagSpec == null ? void 0 : flagSpec.contextEvaluator);
    const variant = isContextEval ? (_a = flagSpec.contextEvaluator) == null ? void 0 : _a.call(flagSpec, ctx) : flagSpec.defaultVariant;
    const value = variant && (flagSpec == null ? void 0 : flagSpec.variants[variant]);
    if (value === void 0) {
      const message = `no value associated with variant ${variant}`;
      logger == null ? void 0 : logger.error(message);
      throw new VariantFoundError(message);
    }
    return __spreadProps(__spreadValues({
      value
    }, variant && { variant }), {
      reason: isContextEval ? StandardResolutionReasons.TARGETING_MATCH : StandardResolutionReasons.STATIC
    });
  }
};

// src/open-feature.ts
var GLOBAL_OPENFEATURE_API_KEY = Symbol.for("@openfeature/js-sdk/api");
var _globalThis = globalThis;
var OpenFeatureAPI = class extends OpenFeatureCommonAPI {
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor() {
    super("server");
    this._defaultProvider = NOOP_PROVIDER;
  }
  /**
   * Gets a singleton instance of the OpenFeature API.
   * @ignore
   * @returns {OpenFeatureAPI} OpenFeature API
   */
  static getInstance() {
    const globalApi = _globalThis[GLOBAL_OPENFEATURE_API_KEY];
    if (globalApi) {
      return globalApi;
    }
    const instance = new OpenFeatureAPI();
    _globalThis[GLOBAL_OPENFEATURE_API_KEY] = instance;
    return instance;
  }
  setContext(context) {
    this._context = context;
    return this;
  }
  getContext() {
    return this._context;
  }
  getClient(nameOrContext, versionOrContext, contextOrUndefined) {
    var _a, _b;
    const name = stringOrUndefined(nameOrContext);
    const version = stringOrUndefined(versionOrContext);
    const context = (_b = (_a = objectOrUndefined(nameOrContext)) != null ? _a : objectOrUndefined(versionOrContext)) != null ? _b : objectOrUndefined(contextOrUndefined);
    return new OpenFeatureClient(
      () => this.getProviderForClient(name),
      () => this.buildAndCacheEventEmitterForClient(name),
      () => this._logger,
      { name, version },
      context
    );
  }
};
var OpenFeature = OpenFeatureAPI.getInstance();

// src/client/open-feature-client.ts
var OpenFeatureClient = class {
  constructor(providerAccessor, emitterAccessor, globalLogger, options, context = {}) {
    this.providerAccessor = providerAccessor;
    this.emitterAccessor = emitterAccessor;
    this.globalLogger = globalLogger;
    this.options = options;
    this._hooks = [];
    this._context = context;
  }
  get metadata() {
    return {
      name: this.options.name,
      version: this.options.version,
      providerMetadata: this.providerAccessor().metadata
    };
  }
  addHandler(eventType, handler) {
    var _a;
    this.emitterAccessor().addHandler(eventType, handler);
    const shouldRunNow = statusMatchesEvent(eventType, this._provider.status);
    if (shouldRunNow) {
      try {
        handler({ clientName: this.metadata.name, providerName: this._provider.metadata.name });
      } catch (err) {
        (_a = this._logger) == null ? void 0 : _a.error("Error running event handler:", err);
      }
    }
  }
  removeHandler(eventType, handler) {
    this.emitterAccessor().removeHandler(eventType, handler);
  }
  getHandlers(eventType) {
    return this.emitterAccessor().getHandlers(eventType);
  }
  setLogger(logger) {
    this._clientLogger = new SafeLogger(logger);
    return this;
  }
  setContext(context) {
    this._context = context;
    return this;
  }
  getContext() {
    return this._context;
  }
  addHooks(...hooks) {
    this._hooks = [...this._hooks, ...hooks];
    return this;
  }
  getHooks() {
    return this._hooks;
  }
  clearHooks() {
    this._hooks = [];
    return this;
  }
  getBooleanValue(flagKey, defaultValue, context, options) {
    return __async(this, null, function* () {
      return (yield this.getBooleanDetails(flagKey, defaultValue, context, options)).value;
    });
  }
  getBooleanDetails(flagKey, defaultValue, context, options) {
    return this.evaluate(
      flagKey,
      this._provider.resolveBooleanEvaluation,
      defaultValue,
      "boolean",
      context,
      options
    );
  }
  getStringValue(flagKey, defaultValue, context, options) {
    return __async(this, null, function* () {
      return (yield this.getStringDetails(flagKey, defaultValue, context, options)).value;
    });
  }
  getStringDetails(flagKey, defaultValue, context, options) {
    return this.evaluate(
      flagKey,
      // this isolates providers from our restricted string generic argument.
      this._provider.resolveStringEvaluation,
      defaultValue,
      "string",
      context,
      options
    );
  }
  getNumberValue(flagKey, defaultValue, context, options) {
    return __async(this, null, function* () {
      return (yield this.getNumberDetails(flagKey, defaultValue, context, options)).value;
    });
  }
  getNumberDetails(flagKey, defaultValue, context, options) {
    return this.evaluate(
      flagKey,
      // this isolates providers from our restricted number generic argument.
      this._provider.resolveNumberEvaluation,
      defaultValue,
      "number",
      context,
      options
    );
  }
  getObjectValue(flagKey, defaultValue, context, options) {
    return __async(this, null, function* () {
      return (yield this.getObjectDetails(flagKey, defaultValue, context, options)).value;
    });
  }
  getObjectDetails(flagKey, defaultValue, context, options) {
    return this.evaluate(flagKey, this._provider.resolveObjectEvaluation, defaultValue, "object", context, options);
  }
  evaluate(_0, _1, _2, _3) {
    return __async(this, arguments, function* (flagKey, resolver, defaultValue, flagType, invocationContext = {}, options = {}) {
      var _a;
      const allHooks = [
        ...OpenFeature.getHooks(),
        ...this.getHooks(),
        ...options.hooks || [],
        ...this._provider.hooks || []
      ];
      const allHooksReversed = [...allHooks].reverse();
      const mergedContext = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, OpenFeature.getContext()), OpenFeature.getTransactionContext()), this._context), invocationContext);
      const hookContext = {
        flagKey,
        defaultValue,
        flagValueType: flagType,
        clientMetadata: this.metadata,
        providerMetadata: OpenFeature.providerMetadata,
        context: mergedContext,
        logger: this._logger
      };
      try {
        const frozenContext = yield this.beforeHooks(allHooks, hookContext, options);
        const resolution = yield resolver.call(this._provider, flagKey, defaultValue, frozenContext, this._logger);
        const evaluationDetails = __spreadProps(__spreadValues({}, resolution), {
          flagMetadata: Object.freeze((_a = resolution.flagMetadata) != null ? _a : {}),
          flagKey
        });
        yield this.afterHooks(allHooksReversed, hookContext, evaluationDetails, options);
        return evaluationDetails;
      } catch (err) {
        const errorMessage = err == null ? void 0 : err.message;
        const errorCode = (err == null ? void 0 : err.code) || "GENERAL" /* GENERAL */;
        yield this.errorHooks(allHooksReversed, hookContext, err, options);
        return {
          errorCode,
          errorMessage,
          value: defaultValue,
          reason: StandardResolutionReasons.ERROR,
          flagMetadata: Object.freeze({}),
          flagKey
        };
      } finally {
        yield this.finallyHooks(allHooksReversed, hookContext, options);
      }
    });
  }
  beforeHooks(hooks, hookContext, options) {
    return __async(this, null, function* () {
      var _a;
      for (const hook of hooks) {
        Object.freeze(hookContext);
        Object.assign(hookContext.context, __spreadValues(__spreadValues({}, hookContext.context), yield (_a = hook == null ? void 0 : hook.before) == null ? void 0 : _a.call(hook, hookContext, Object.freeze(options.hookHints))));
      }
      return Object.freeze(hookContext.context);
    });
  }
  afterHooks(hooks, hookContext, evaluationDetails, options) {
    return __async(this, null, function* () {
      var _a;
      for (const hook of hooks) {
        yield (_a = hook == null ? void 0 : hook.after) == null ? void 0 : _a.call(hook, hookContext, evaluationDetails, options.hookHints);
      }
    });
  }
  errorHooks(hooks, hookContext, err, options) {
    return __async(this, null, function* () {
      var _a;
      for (const hook of hooks) {
        try {
          yield (_a = hook == null ? void 0 : hook.error) == null ? void 0 : _a.call(hook, hookContext, err, options.hookHints);
        } catch (err2) {
          this._logger.error(`Unhandled error during 'error' hook: ${err2}`);
          if (err2 instanceof Error) {
            this._logger.error(err2.stack);
          }
          this._logger.error(err2 == null ? void 0 : err2.stack);
        }
      }
    });
  }
  finallyHooks(hooks, hookContext, options) {
    return __async(this, null, function* () {
      var _a;
      for (const hook of hooks) {
        try {
          yield (_a = hook == null ? void 0 : hook.finally) == null ? void 0 : _a.call(hook, hookContext, options.hookHints);
        } catch (err) {
          this._logger.error(`Unhandled error during 'finally' hook: ${err}`);
          if (err instanceof Error) {
            this._logger.error(err.stack);
          }
          this._logger.error(err == null ? void 0 : err.stack);
        }
      }
    });
  }
  get _provider() {
    return this.providerAccessor();
  }
  get _logger() {
    return this._clientLogger || this.globalLogger();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DefaultLogger,
  ErrorCode,
  FlagNotFoundError,
  GeneralError,
  InMemoryProvider,
  InternalEventEmitter,
  InvalidContextError,
  LOG_LEVELS,
  NOOP_PROVIDER,
  NOOP_TRANSACTION_CONTEXT_PROPAGATOR,
  OpenFeature,
  OpenFeatureAPI,
  OpenFeatureClient,
  OpenFeatureCommonAPI,
  OpenFeatureError,
  OpenFeatureEventEmitter,
  ParseError,
  ProviderEvents,
  ProviderStatus,
  SafeLogger,
  StandardResolutionReasons,
  TargetingKeyMissingError,
  TypeMismatchError,
  isObject,
  isString,
  objectOrUndefined,
  statusMatchesEvent,
  stringOrUndefined
});
//# sourceMappingURL=index.js.map
