{
  "version": 3,
  "sources": ["../../src/index.ts", "../../../shared/src/errors/open-feature-error-abstract.ts", "../../../shared/src/evaluation/evaluation.ts", "../../../shared/src/errors/general-error.ts", "../../../shared/src/errors/flag-not-found-error.ts", "../../../shared/src/errors/parse-error.ts", "../../../shared/src/errors/type-mismatch-error.ts", "../../../shared/src/errors/targeting-key-missing-error.ts", "../../../shared/src/errors/invalid-context-error.ts", "../../../shared/src/provider/provider.ts", "../../../shared/src/events/events.ts", "../../../shared/src/events/event-utils.ts", "../../../shared/src/events/open-feature-event-emitter.ts", "../../../shared/src/logger/default-logger.ts", "../../../shared/src/logger/safe-logger.ts", "../../../shared/src/transaction-context/no-op-transaction-context-propagator.ts", "../../../shared/src/type-guards.ts", "../../../shared/src/filter.ts", "../../../shared/src/open-feature.ts", "../../src/provider/no-op-provider.ts", "../../src/provider/in-memory-provider/variant-not-found-error.ts", "../../src/provider/in-memory-provider/in-memory-provider.ts", "../../src/open-feature.ts", "../../src/client/open-feature-client.ts"],
  "sourcesContent": ["export * from './client';\nexport * from './provider';\nexport * from './evaluation';\nexport * from './open-feature';\nexport * from '@openfeature/shared';\n", "import { ErrorCode } from '../evaluation';\n\nexport abstract class OpenFeatureError extends Error {\n  abstract code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, OpenFeatureError.prototype);\n    this.name = 'OpenFeatureError';\n  }\n}\n", "export type FlagValueType = 'boolean' | 'string' | 'number' | 'object';\n\nexport type PrimitiveValue = null | boolean | string | number;\nexport type JsonObject = { [key: string]: JsonValue };\nexport type JsonArray = JsonValue[];\n\n/**\n * Represents a JSON node value.\n */\nexport type JsonValue = PrimitiveValue | JsonObject | JsonArray;\n\n/**\n * Represents a JSON node value, or Date.\n */\nexport type FlagValue = boolean | string | number | JsonValue;\n\nexport type ResolutionReason = keyof typeof StandardResolutionReasons | (string & Record<never, never>);\n\n/**\n * A structure which supports definition of arbitrary properties, with keys of type string, and values of type boolean, string, or number.\n *\n * This structure is populated by a provider for use by an Application Author (via the Evaluation API) or an Application Integrator (via hooks).\n */\nexport type FlagMetadata = Record<string, string | number | boolean>;\n\nexport type ResolutionDetails<U> = {\n  value: U;\n  variant?: string;\n  flagMetadata?: FlagMetadata;\n  reason?: ResolutionReason;\n  errorCode?: ErrorCode;\n  errorMessage?: string;\n};\n\nexport type EvaluationDetails<T extends FlagValue> = {\n  flagKey: string;\n  flagMetadata: Readonly<FlagMetadata>;\n} & ResolutionDetails<T>;\n\nexport const StandardResolutionReasons = {\n  /**\n   * The resolved value was the result of a dynamic evaluation, such as a rule or specific user-targeting.\n   */\n  TARGETING_MATCH: 'TARGETING_MATCH',\n\n  /**\n   * The resolved value was the result of pseudorandom assignment.\n   */\n  SPLIT: 'SPLIT',\n\n  /**\n   * The resolved value was the result of the flag being disabled in the management system.\n   */\n  DISABLED: 'DISABLED',\n\n  /**\n   *  The resolved value was configured statically, or otherwise fell back to a pre-configured value.\n   */\n  DEFAULT: 'DEFAULT',\n\n  /**\n   * The reason for the resolved value could not be determined.\n   */\n  UNKNOWN: 'UNKNOWN',\n\n  /**\n   * The resolved value is static (no dynamic evaluation).\n   */\n  STATIC: 'STATIC',\n\n  /**\n   * The resolved value was retrieved from cache.\n   */\n  CACHED: 'CACHED',\n\n  /**\n   * The resolved value was the result of an error.\n   *\n   * Note: The `errorCode` and `errorMessage` fields may contain additional details of this error.\n   */\n  ERROR: 'ERROR',\n} as const;\n\nexport enum ErrorCode {\n  /**\n   * The value was resolved before the provider was ready.\n   */\n  PROVIDER_NOT_READY = 'PROVIDER_NOT_READY',\n\n  /**\n   * The flag could not be found.\n   */\n  FLAG_NOT_FOUND = 'FLAG_NOT_FOUND',\n\n  /**\n   * An error was encountered parsing data, such as a flag configuration.\n   */\n  PARSE_ERROR = 'PARSE_ERROR',\n\n  /**\n   * The type of the flag value does not match the expected type.\n   */\n  TYPE_MISMATCH = 'TYPE_MISMATCH',\n\n  /**\n   * The provider requires a targeting key and one was not provided in the evaluation context.\n   */\n  TARGETING_KEY_MISSING = 'TARGETING_KEY_MISSING',\n\n  /**\n   * The evaluation context does not meet provider requirements.\n   */\n  INVALID_CONTEXT = 'INVALID_CONTEXT',\n\n  /**\n   * An error with an unspecified code.\n   */\n  GENERAL = 'GENERAL',\n}\n", "import { OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class GeneralError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, GeneralError.prototype);\n    this.name = 'GeneralError';\n    this.code = ErrorCode.GENERAL;\n  }\n}\n", "import { OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class FlagNotFoundError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, FlagNotFoundError.prototype);\n    this.name = 'FlagNotFoundError';\n    this.code = ErrorCode.FLAG_NOT_FOUND;\n  }\n}\n", "import { OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class ParseError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, ParseError.prototype);\n    this.name = 'ParseError';\n    this.code = ErrorCode.PARSE_ERROR;\n  }\n}\n", "import { OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class TypeMismatchError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, TypeMismatchError.prototype);\n    this.name = 'TypeMismatchError';\n    this.code = ErrorCode.TYPE_MISMATCH;\n  }\n}\n", "import { OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class TargetingKeyMissingError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, TargetingKeyMissingError.prototype);\n    this.name = 'TargetingKeyMissingError';\n    this.code = ErrorCode.TARGETING_KEY_MISSING;\n  }\n}\n", "import { OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class InvalidContextError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, InvalidContextError.prototype);\n    this.name = 'InvalidContextError';\n    this.code = ErrorCode.INVALID_CONTEXT;\n  }\n}\n", "import { EvaluationContext } from '../evaluation';\nimport { OpenFeatureEventEmitter } from '../events';\nimport { Metadata, Paradigm } from '../types';\n\n/**\n * The state of the provider.\n */\nexport enum ProviderStatus {\n  /**\n   * The provider has not been initialized and cannot yet evaluate flags.\n   */\n  NOT_READY = 'NOT_READY',\n\n  /**\n   * The provider is ready to resolve flags.\n   */\n  READY = 'READY',\n\n  /**\n   * The provider is in an error state and unable to evaluate flags.\n   */\n  ERROR = 'ERROR',\n\n  /**\n   * The provider's cached state is no longer valid and may not be up-to-date with the source of truth.\n   */\n  STALE = 'STALE',\n}\n\n/**\n * Static data about the provider.\n */\nexport interface ProviderMetadata extends Metadata {\n  readonly name: string;\n}\n\nexport interface CommonProvider {\n  readonly metadata: ProviderMetadata;\n\n  /**\n   * Represents where the provider is intended to be run. If defined,\n   * the SDK will enforce that the defined paradigm at runtime.\n   */\n  readonly runsOn?: Paradigm;\n\n  /**\n   * Returns a representation of the current readiness of the provider.\n   * If the provider needs to be initialized, it should return {@link ProviderStatus.READY}.\n   * If the provider is in an error state, it should return {@link ProviderStatus.ERROR}.\n   * If the provider is functioning normally, it should return {@link ProviderStatus.NOT_READY}.\n   * \n   * _Providers which do not implement this method are assumed to be ready immediately._\n   */\n  readonly status?: ProviderStatus;\n\n  /**\n   * An event emitter for ProviderEvents.\n   * @see ProviderEvents\n   */\n  events?: OpenFeatureEventEmitter;\n\n  /**\n   * A function used to shut down the provider.\n   * Called when this provider is replaced with a new one, or when the OpenFeature is shut down.\n   */\n  onClose?(): Promise<void>;\n\n  /**\n   * A function used to setup the provider.\n   * Called by the SDK after the provider is set if the provider's status is {@link ProviderStatus.NOT_READY}.\n   * When the returned promise resolves, the SDK fires the ProviderEvents.Ready event.\n   * If the returned promise rejects, the SDK fires the ProviderEvents.Error event.\n   * Use this function to perform any context-dependent setup within the provider.\n   * @param context\n   */\n  initialize?(context?: EvaluationContext): Promise<void>;\n}", "export enum ProviderEvents {\n  /**\n   * The provider is ready to evaluate flags.\n   */\n  Ready = 'PROVIDER_READY',\n\n  /**\n   * The provider is in an error state.\n   */\n  Error = 'PROVIDER_ERROR',\n\n  /**\n   * The flag configuration in the source-of-truth has changed.\n   */\n  ConfigurationChanged = 'PROVIDER_CONFIGURATION_CHANGED',\n\n  /**\n   * The provider's cached state is no longer valid and may not be up-to-date with the source of truth.\n   */\n  Stale = 'PROVIDER_STALE',\n}\n", "import { ProviderStatus } from '../provider';\nimport { ProviderEvents } from './events';\n\nconst eventStatusMap = {\n    [ProviderStatus.READY]: ProviderEvents.Ready,\n    [ProviderStatus.ERROR]: ProviderEvents.Error,\n    [ProviderStatus.STALE]: ProviderEvents.Stale,\n    [ProviderStatus.NOT_READY]: undefined,\n};\n\n/**\n * Returns true if the provider's status corresponds to the event.\n * If the provider's status is not defined, it matches READY.\n * @param {ProviderEvents} event event to match\n * @param {ProviderStatus} status  status of provider\n * @returns {boolean} boolean indicating if the provider status corresponds to the event.\n */\nexport const statusMatchesEvent = (event: ProviderEvents, status?: ProviderStatus): boolean => {\n    return (!status && event === ProviderEvents.Ready) || eventStatusMap[status!] === event;\n};", "import EventEmitter from 'events';\nimport { Logger, ManageLogger, SafeLogger } from '../logger';\nimport { CommonEventDetails, EventContext, EventDetails, EventHandler } from './eventing';\nimport { ProviderEvents } from './events';\n\nabstract class GenericEventEmitter<AdditionalContext extends Record<string, unknown> = Record<string, unknown>>\n  implements ManageLogger<GenericEventEmitter<AdditionalContext>>\n{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private readonly _handlers = new WeakMap<EventHandler<any>, EventHandler<any>>();\n  private readonly eventEmitter = new EventEmitter({ captureRejections: true });\n  private _eventLogger?: Logger;\n\n  constructor(private readonly globalLogger?: () => Logger) {\n    this.eventEmitter.on('error', (err) => {\n      this._logger?.error('Error running event handler:', err);\n    });\n  }\n\n  emit<T extends ProviderEvents>(eventType: T, context?: EventContext<T, AdditionalContext>): void {\n    this.eventEmitter.emit(eventType, context);\n  }\n\n  addHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void {\n    // The handlers have to be wrapped with an async function because if a synchronous functions throws an error,\n    // the other handlers will not run.\n    const asyncHandler = async (details?: EventDetails<T>) => {\n      await handler(details);\n    };\n    // The async handler has to be written to the map, because we need to get the wrapper function when deleting a listener\n    this._handlers.set(handler, asyncHandler);\n    this.eventEmitter.on(eventType, asyncHandler);\n  }\n\n  removeHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void {\n    // Get the wrapper function for this handler, to delete it from the event emitter\n    const asyncHandler = this._handlers.get(handler) as EventHandler<T> | undefined;\n\n    if (!asyncHandler) {\n      return;\n    }\n\n    this.eventEmitter.removeListener(eventType, asyncHandler);\n  }\n\n  removeAllHandlers(eventType?: ProviderEvents): void {\n    // If giving undefined, the listeners are not removed, so we have to check explicitly\n    if (eventType) {\n      this.eventEmitter.removeAllListeners(eventType);\n    } else {\n      this.eventEmitter.removeAllListeners();\n    }\n  }\n\n  getHandlers<T extends ProviderEvents>(eventType: T): EventHandler<T>[] {\n    return this.eventEmitter.listeners(eventType) as EventHandler<T>[];\n  }\n\n  setLogger(logger: Logger): this {\n    this._eventLogger = new SafeLogger(logger);\n    return this;\n  }\n\n  private get _logger() {\n    return this._eventLogger ?? this.globalLogger?.();\n  }\n}\n\n/**\n * The OpenFeatureEventEmitter can be used by provider developers to emit\n * events at various parts of the provider lifecycle.\n * \n * NOTE: Ready and error events are automatically emitted by the SDK based on\n * the result of the initialize method.\n */\nexport class OpenFeatureEventEmitter extends GenericEventEmitter {};\n\n/**\n * The InternalEventEmitter should only be used within the SDK. It extends the\n * OpenFeatureEventEmitter to include additional properties that can be included\n * in the event details.\n */\nexport class InternalEventEmitter extends GenericEventEmitter<CommonEventDetails> {};", "/* eslint-disable @typescript-eslint/no-empty-function */\n\nimport { Logger } from './logger';\n\nexport class DefaultLogger implements Logger {\n  error(...args: unknown[]): void {\n    console.error(...args);\n  }\n\n  warn(...args: unknown[]): void {\n    console.warn(...args);\n  }\n\n  info(): void {}\n\n  debug(): void {}\n}\n", "import { Logger } from './logger';\nimport { DefaultLogger } from './default-logger';\n\nexport const LOG_LEVELS: Array<keyof Logger> = ['error', 'warn', 'info', 'debug'];\n\nexport class SafeLogger implements Logger {\n  private readonly logger: Logger;\n  private readonly fallbackLogger = new DefaultLogger();\n\n  constructor(logger: Logger) {\n    try {\n      for (const level of LOG_LEVELS) {\n        if (!logger[level] || typeof logger[level] !== 'function') {\n          throw new Error(`The provided logger is missing the ${level} method.`);\n        }\n      }\n      this.logger = logger;\n    } catch (err) {\n      console.error(err);\n      console.error('Falling back to the default logger.');\n      this.logger = this.fallbackLogger;\n    }\n  }\n\n  error(...args: unknown[]): void {\n    this.log('error', ...args);\n  }\n\n  warn(...args: unknown[]): void {\n    this.log('warn', ...args);\n  }\n\n  info(...args: unknown[]): void {\n    this.log('info', ...args);\n  }\n\n  debug(...args: unknown[]): void {\n    this.log('debug', ...args);\n  }\n\n  private log(level: keyof Logger, ...args: unknown[]) {\n    try {\n      this.logger[level](...args);\n    } catch (error) {\n      this.fallbackLogger[level](...args);\n    }\n  }\n}\n", "import { EvaluationContext } from '../evaluation';\nimport { TransactionContextPropagator } from './transaction-context';\n\nclass NoopTransactionContextPropagator implements TransactionContextPropagator {\n  getTransactionContext(): EvaluationContext {\n    return {};\n  }\n\n  setTransactionContext(_: EvaluationContext, callback: () => void): void {\n    callback();\n  }\n}\n\nexport const NOOP_TRANSACTION_CONTEXT_PROPAGATOR = new NoopTransactionContextPropagator();\n", "/**\n * Checks whether the parameter is a string.\n * @param {unknown} value The value to check\n * @returns {value is string} True if the value is a string\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Returns the parameter if it is a string, otherwise returns undefined.\n * @param {unknown} value The value to check\n * @returns {string|undefined} The parameter if it is a string, otherwise undefined\n */\nexport function stringOrUndefined(value: unknown): string | undefined {\n  return isString(value) ? value : undefined;\n}\n\n/**\n * Checks whether the parameter is an object.\n * @param {unknown} value The value to check\n * @returns {value is string} True if the value is an object\n */\nexport function isObject<T extends object>(value: unknown): value is T {\n  return typeof value === 'object';\n}\n\n/**\n * Returns the parameter if it is an object, otherwise returns undefined.\n * @param {unknown} value The value to check\n * @returns {object|undefined} The parameter if it is an object, otherwise undefined\n */\nexport function objectOrUndefined<T extends object>(value: unknown): T | undefined {\n  return isObject<T>(value) ? value : undefined;\n}\n", "/**\n * Checks if a value is not null or undefined and returns it as type assertion\n * @template T\n * @param {T} input The value to check\n * @returns {T} If the value is not null or undefined\n */\nexport function isDefined<T>(input?: T | null | undefined): input is T {\n  return typeof input !== 'undefined' && input !== null;\n}\n", "import { GeneralError } from './errors';\nimport { EvaluationContext, FlagValue } from './evaluation';\nimport { EventDetails, EventHandler, Eventing, ProviderEvents, statusMatchesEvent } from './events';\nimport { InternalEventEmitter } from './events/open-feature-event-emitter';\nimport { isDefined } from './filter';\nimport { EvaluationLifeCycle, Hook } from './hooks';\nimport { DefaultLogger, Logger, ManageLogger, SafeLogger } from './logger';\nimport { CommonProvider, ProviderMetadata, ProviderStatus } from './provider';\nimport {\n  ManageTransactionContextPropagator,\n  NOOP_TRANSACTION_CONTEXT_PROPAGATOR,\n  TransactionContext,\n  TransactionContextPropagator,\n} from './transaction-context';\nimport { objectOrUndefined, stringOrUndefined } from './type-guards';\nimport { Paradigm } from './types';\n\nexport abstract class OpenFeatureCommonAPI<P extends CommonProvider = CommonProvider>\n  implements\n    Eventing,\n    EvaluationLifeCycle<OpenFeatureCommonAPI<P>>,\n    ManageLogger<OpenFeatureCommonAPI<P>>,\n    ManageTransactionContextPropagator<OpenFeatureCommonAPI<P>>\n{\n  protected _hooks: Hook[] = [];\n  protected _transactionContextPropagator: TransactionContextPropagator = NOOP_TRANSACTION_CONTEXT_PROPAGATOR;\n  protected _context: EvaluationContext = {};\n  protected _logger: Logger = new DefaultLogger();\n\n  protected abstract _defaultProvider: P;\n\n  private readonly _events = new InternalEventEmitter(() => this._logger);\n  private readonly _clientEventHandlers: Map<string | undefined, [ProviderEvents, EventHandler<ProviderEvents>][]> =\n    new Map();\n  protected _clientProviders: Map<string, P> = new Map();\n  protected _clientEvents: Map<string | undefined, InternalEventEmitter> = new Map();\n  protected _runsOn: Paradigm;\n\n  constructor(category: Paradigm) {\n    this._runsOn = category;\n  }\n\n  addHooks(...hooks: Hook<FlagValue>[]): this {\n    this._hooks = [...this._hooks, ...hooks];\n    return this;\n  }\n\n  getHooks(): Hook<FlagValue>[] {\n    return this._hooks;\n  }\n\n  clearHooks(): this {\n    this._hooks = [];\n    return this;\n  }\n\n  setLogger(logger: Logger): this {\n    this._logger = new SafeLogger(logger);\n    return this;\n  }\n\n  /**\n   * Get metadata about registered provider.\n   * @returns {ProviderMetadata} Provider Metadata\n   */\n  get providerMetadata(): ProviderMetadata {\n    return this._defaultProvider.metadata;\n  }\n\n  /**\n   * Adds a handler for the given provider event type.\n   * The handlers are called in the order they have been added.\n   * API (global) events run for all providers.\n   * @param {ProviderEvents} eventType The provider event type to listen to\n   * @param {EventHandler} handler The handler to run on occurrence of the event type\n   */\n  addHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void {\n    [...new Map([[undefined, this._defaultProvider]]), ...this._clientProviders].forEach((keyProviderTuple) => {\n      const clientName = keyProviderTuple[0];\n      const provider = keyProviderTuple[1];\n      const shouldRunNow = statusMatchesEvent(eventType, keyProviderTuple[1].status);\n\n      if (shouldRunNow) {\n        // run immediately, we're in the matching state\n        try {\n          handler({ clientName, providerName: provider.metadata.name });\n        } catch (err) {\n          this._logger?.error('Error running event handler:', err);\n        }\n      }\n    });\n\n    this._events.addHandler(eventType, handler);\n  }\n\n  /**\n   * Removes a handler for the given provider event type.\n   * @param {ProviderEvents} eventType The provider event type to remove the listener for\n   * @param {EventHandler} handler The handler to remove for the provider event type\n   */\n  removeHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void {\n    this._events.removeHandler(eventType, handler);\n  }\n\n  /**\n   * Gets the current handlers for the given provider event type.\n   * @param {ProviderEvents} eventType The provider event type to get the current handlers for\n   * @returns {EventHandler[]} The handlers currently attached to the given provider event type\n   */\n  getHandlers<T extends ProviderEvents>(eventType: T): EventHandler<T>[] {\n    return this._events.getHandlers(eventType);\n  }\n\n  /**\n   * Sets the default provider for flag evaluations and returns a promise that resolves when the provider is ready.\n   * This provider will be used by unnamed clients and named clients to which no provider is bound.\n   * Setting a provider supersedes the current provider used in new and existing clients without a name.\n   * @template P\n   * @param {P} provider The provider responsible for flag evaluations.\n   * @returns {Promise<void>}\n   * @throws Uncaught exceptions thrown by the provider during initialization.\n   */\n  async setProviderAndWait(provider: P): Promise<void>;\n  /**\n   * Sets the provider that OpenFeature will use for flag evaluations of providers with the given name.\n   * A promise is returned that resolves when the provider is ready.\n   * Setting a provider supersedes the current provider used in new and existing clients with that name.\n   * @template P\n   * @param {string} clientName The name to identify the client\n   * @param {P} provider The provider responsible for flag evaluations.\n   * @returns {Promise<void>}\n   * @throws Uncaught exceptions thrown by the provider during initialization.\n   */\n  async setProviderAndWait(clientName: string, provider: P): Promise<void>;\n  async setProviderAndWait(clientOrProvider?: string | P, providerOrUndefined?: P): Promise<void> {\n    await this.setAwaitableProvider(clientOrProvider, providerOrUndefined);\n  }\n\n  /**\n   * Sets the default provider for flag evaluations.\n   * This provider will be used by unnamed clients and named clients to which no provider is bound.\n   * Setting a provider supersedes the current provider used in new and existing clients without a name.\n   * @template P\n   * @param {P} provider The provider responsible for flag evaluations.\n   * @returns {this} OpenFeature API\n   */\n  setProvider(provider: P): this;\n  /**\n   * Sets the provider that OpenFeature will use for flag evaluations of providers with the given name.\n   * Setting a provider supersedes the current provider used in new and existing clients with that name.\n   * @template P\n   * @param {string} clientName The name to identify the client\n   * @param {P} provider The provider responsible for flag evaluations.\n   * @returns {this} OpenFeature API\n   */\n  setProvider(clientName: string, provider: P): this;\n  setProvider(clientOrProvider?: string | P, providerOrUndefined?: P): this {\n    const maybePromise = this.setAwaitableProvider(clientOrProvider, providerOrUndefined);\n    if (maybePromise) {\n      maybePromise.catch(() => {\n        /* ignore, errors are emitted via the event emitter */\n      });\n    }\n    return this;\n  }\n\n  private setAwaitableProvider(clientOrProvider?: string | P, providerOrUndefined?: P): Promise<void> | void {\n    const clientName = stringOrUndefined(clientOrProvider);\n    const provider = objectOrUndefined<P>(clientOrProvider) ?? objectOrUndefined<P>(providerOrUndefined);\n\n    if (!provider) {\n      this._logger.debug('No provider defined, ignoring setProvider call');\n      return;\n    }\n\n    const oldProvider = this.getProviderForClient(clientName);\n    const providerName = provider.metadata.name;\n\n    // ignore no-ops\n    if (oldProvider === provider) {\n      this._logger.debug('Provider is already set, ignoring setProvider call');\n      return;\n    }\n\n    if (!provider.runsOn) {\n      this._logger.debug(`Provider '${provider.metadata.name}' has not defined its intended use.`);\n    } else if (provider.runsOn !== this._runsOn) {\n      throw new GeneralError(`Provider '${provider.metadata.name}' is intended for use on the ${provider.runsOn}.`);\n    }\n\n    const emitters = this.getAssociatedEventEmitters(clientName);\n\n    // warn of improper implementations\n    if (typeof provider.initialize === 'function' && provider.status === undefined) {\n      const activeLogger = this._logger || console;\n      activeLogger.warn(\n        `Provider ${providerName} implements 'initialize' but not 'status'. Please implement 'status'.`\n      );\n    }\n\n    let initializationPromise: Promise<void> | void = undefined;\n\n    if (provider?.status === ProviderStatus.NOT_READY && typeof provider.initialize === 'function') {\n      initializationPromise = provider\n        .initialize?.(this._context)\n        ?.then(() => {\n          // fetch the most recent event emitters, some may have been added during init\n          this.getAssociatedEventEmitters(clientName).forEach((emitter) => {\n            emitter?.emit(ProviderEvents.Ready, { clientName, providerName });\n          });\n          this._events?.emit(ProviderEvents.Ready, { clientName, providerName });\n        })\n        ?.catch((error) => {\n          this.getAssociatedEventEmitters(clientName).forEach((emitter) => {\n            emitter?.emit(ProviderEvents.Error, { clientName, providerName, message: error.message });\n          });\n          this._events?.emit(ProviderEvents.Error, { clientName, providerName, message: error.message });\n          // rethrow after emitting error events, so that public methods can control error handling\n          throw error;\n        });\n    } else {\n      emitters.forEach((emitter) => {\n        emitter?.emit(ProviderEvents.Ready, { clientName, providerName });\n      });\n      this._events?.emit(ProviderEvents.Ready, { clientName, providerName });\n    }\n\n    if (clientName) {\n      this._clientProviders.set(clientName, provider);\n    } else {\n      this._defaultProvider = provider;\n    }\n\n    this.transferListeners(oldProvider, provider, clientName, emitters);\n\n    // Do not close a provider that is bound to any client\n    if (![...this._clientProviders.values(), this._defaultProvider].includes(oldProvider)) {\n      oldProvider?.onClose?.();\n    }\n\n    return initializationPromise;\n  }\n\n  protected getProviderForClient(name?: string): P {\n    if (!name) {\n      return this._defaultProvider;\n    }\n\n    return this._clientProviders.get(name) ?? this._defaultProvider;\n  }\n\n  protected buildAndCacheEventEmitterForClient(name?: string): InternalEventEmitter {\n    const emitter = this._clientEvents.get(name);\n\n    if (emitter) {\n      return emitter;\n    }\n\n    // lazily add the event emitters\n    const newEmitter = new InternalEventEmitter(() => this._logger);\n    this._clientEvents.set(name, newEmitter);\n\n    const clientProvider = this.getProviderForClient(name);\n    Object.values<ProviderEvents>(ProviderEvents).forEach((eventType) =>\n      clientProvider.events?.addHandler(eventType, async (details) => {\n        newEmitter.emit(eventType, { ...details, clientName: name, providerName: clientProvider.metadata.name });\n      })\n    );\n\n    return newEmitter;\n  }\n\n  private getUnboundEmitters(): InternalEventEmitter[] {\n    const namedProviders = [...this._clientProviders.keys()];\n    const eventEmitterNames = [...this._clientEvents.keys()].filter(isDefined);\n    const unboundEmitterNames = eventEmitterNames.filter((name) => !namedProviders.includes(name));\n    return [\n      // all unbound, named emitters\n      ...unboundEmitterNames.map((name) => this._clientEvents.get(name)),\n      // the default emitter\n      this._clientEvents.get(undefined),\n    ].filter(isDefined);\n  }\n\n  private getAssociatedEventEmitters(clientName: string | undefined) {\n    return clientName ? [this.buildAndCacheEventEmitterForClient(clientName)] : this.getUnboundEmitters();\n  }\n\n  private transferListeners(\n    oldProvider: P,\n    newProvider: P,\n    clientName: string | undefined,\n    emitters: (InternalEventEmitter | undefined)[]\n  ) {\n    this._clientEventHandlers\n      .get(clientName)\n      ?.forEach((eventHandler) => oldProvider.events?.removeHandler(...eventHandler));\n\n    // iterate over the event types\n    const newClientHandlers = Object.values<ProviderEvents>(ProviderEvents).map<\n      [ProviderEvents, EventHandler<ProviderEvents>]\n    >((eventType) => {\n      const handler = async (details?: EventDetails<ProviderEvents>) => {\n        // on each event type, fire the associated handlers\n        emitters.forEach((emitter) => {\n          emitter?.emit(eventType, { ...details, clientName, providerName: newProvider.metadata.name });\n        });\n        this._events.emit(eventType, { ...details, clientName, providerName: newProvider.metadata.name });\n      };\n\n      return [eventType, handler];\n    });\n\n    this._clientEventHandlers.set(clientName, newClientHandlers);\n    newClientHandlers.forEach((eventHandler) => newProvider.events?.addHandler(...eventHandler));\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this?._defaultProvider?.onClose?.();\n    } catch (err) {\n      this.handleShutdownError(this._defaultProvider, err);\n    }\n\n    const providers = Array.from(this._clientProviders);\n\n    await Promise.all(\n      providers.map(async ([, provider]) => {\n        try {\n          await provider.onClose?.();\n        } catch (err) {\n          this.handleShutdownError(this._defaultProvider, err);\n        }\n      })\n    );\n  }\n\n  private handleShutdownError(provider: P, err: unknown) {\n    this._logger.error(`Error during shutdown of provider ${provider.metadata.name}: ${err}`);\n    this._logger.error((err as Error)?.stack);\n  }\n\n  setTransactionContextPropagator(transactionContextPropagator: TransactionContextPropagator): OpenFeatureCommonAPI<P> {\n    const baseMessage = 'Invalid TransactionContextPropagator, will not be set: ';\n    if (typeof transactionContextPropagator?.getTransactionContext !== 'function') {\n      this._logger.error(`${baseMessage}: getTransactionContext is not a function.`);\n    } else if (typeof transactionContextPropagator?.setTransactionContext !== 'function') {\n      this._logger.error(`${baseMessage}: setTransactionContext is not a function.`);\n    } else {\n      this._transactionContextPropagator = transactionContextPropagator;\n    }\n    return this;\n  }\n\n  setTransactionContext<R>(\n    transactionContext: TransactionContext,\n    callback: (...args: unknown[]) => R,\n    ...args: unknown[]\n  ): void {\n    this._transactionContextPropagator.setTransactionContext(transactionContext, callback, ...args);\n  }\n\n  getTransactionContext(): TransactionContext {\n    try {\n      return this._transactionContextPropagator.getTransactionContext();\n    } catch (err: unknown) {\n      const error = err as Error | undefined;\n      this._logger.error(`Error getting transaction context: ${error?.message}, returning empty context.`);\n      this._logger.error(error?.stack);\n      return {};\n    }\n  }\n}\n", "import { ResolutionDetails, JsonValue, ProviderStatus } from '@openfeature/shared';\nimport { Provider } from './provider';\n\nconst REASON_NO_OP = 'No-op';\n\n/**\n * The No-op provider is set by default, and simply always returns the default value.\n */\nclass NoopFeatureProvider implements Provider {\n  readonly metadata = {\n    name: 'No-op Provider',\n  } as const;\n\n  get status(): ProviderStatus {\n    /**\n     * This is due to the NoopProvider not being a real provider.\n     * We do not want it to trigger the Ready event handlers, so we never set this to ready.\n     * With the NoopProvider assigned, the client can be assumed to be uninitialized.\n     * https://github.com/open-feature/js-sdk/pull/429#discussion_r1202642654\n     */\n    return ProviderStatus.NOT_READY;\n  }\n\n  resolveBooleanEvaluation(_: string, defaultValue: boolean): Promise<ResolutionDetails<boolean>> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveStringEvaluation(_: string, defaultValue: string): Promise<ResolutionDetails<string>> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveNumberEvaluation(_: string, defaultValue: number): Promise<ResolutionDetails<number>> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveObjectEvaluation<T extends JsonValue>(_: string, defaultValue: T): Promise<ResolutionDetails<T>> {\n    return this.noOp<T>(defaultValue);\n  }\n\n  private noOp<T>(defaultValue: T) {\n    return Promise.resolve({\n      value: defaultValue,\n      reason: REASON_NO_OP,\n    });\n  }\n}\n\nexport const NOOP_PROVIDER = new NoopFeatureProvider();\n", "import { ErrorCode, OpenFeatureError } from '@openfeature/shared';\n\n/**\n * A custom error for the in-memory provider.\n * Indicates the resolved or default variant doesn't exist.\n */\nexport class VariantFoundError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, VariantFoundError.prototype);\n    this.name = 'VariantFoundError';\n    this.code = ErrorCode.GENERAL;\n  }\n}\n", "import {\n  EvaluationContext,\n  FlagNotFoundError,\n  FlagValueType,\n  GeneralError,\n  JsonValue,\n  Logger,\n  OpenFeatureError,\n  OpenFeatureEventEmitter,\n  ProviderEvents,\n  ResolutionDetails,\n  StandardResolutionReasons,\n  TypeMismatchError\n} from '@openfeature/shared';\nimport { Provider } from '../provider';\nimport { Flag, FlagConfiguration } from './flag-configuration';\nimport { VariantFoundError } from './variant-not-found-error';\n\n/**\n * A simple OpenFeature provider intended for demos and as a test stub.\n */\nexport class InMemoryProvider implements Provider {\n  public readonly events = new OpenFeatureEventEmitter();\n  public readonly runsOn = 'server';\n  readonly metadata = {\n    name: 'in-memory',\n  } as const;\n  private _flagConfiguration: FlagConfiguration;\n\n  constructor(flagConfiguration: FlagConfiguration = {}) {\n    this._flagConfiguration = { ...flagConfiguration };\n  }\n\n  /**\n   * Overwrites the configured flags.\n   * @param { FlagConfiguration } flagConfiguration new flag configuration\n   */\n  putConfiguration(flagConfiguration: FlagConfiguration) {\n    const flagsChanged = Object.entries(flagConfiguration)\n      .filter(([key, value]) => this._flagConfiguration[key] !== value)\n      .map(([key]) => key);\n\n    this._flagConfiguration = { ...flagConfiguration };\n    this.events.emit(ProviderEvents.ConfigurationChanged, { flagsChanged });\n  }\n\n  resolveBooleanEvaluation(\n    flagKey: string,\n    defaultValue: boolean,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<boolean>> {\n    return this.resolveFlagWithReason<boolean>(flagKey, defaultValue, context, logger);\n  }\n\n  resolveNumberEvaluation(\n    flagKey: string,\n    defaultValue: number,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<number>> {\n    return this.resolveFlagWithReason<number>(flagKey, defaultValue, context, logger);\n  }\n\n  async resolveStringEvaluation(\n    flagKey: string,\n    defaultValue: string,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<string>> {\n    return this.resolveFlagWithReason<string>(flagKey, defaultValue, context, logger);\n  }\n\n  async resolveObjectEvaluation<T extends JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<T>> {\n    return this.resolveFlagWithReason<T>(flagKey, defaultValue, context, logger);\n  }\n\n  private async resolveFlagWithReason<T extends JsonValue | FlagValueType>(\n    flagKey: string,\n    defaultValue: T,\n    ctx?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<T>> {\n    try {\n      const resolutionResult = this.lookupFlagValue(flagKey, defaultValue, ctx, logger);\n\n      if (typeof resolutionResult?.value != typeof defaultValue) {\n        throw new TypeMismatchError();\n      }\n\n      return resolutionResult;\n    } catch (error: unknown) {\n      if (!(error instanceof OpenFeatureError)) {\n        throw new GeneralError((error as Error)?.message || 'unknown error'); \n      }\n      throw error;\n    }\n  }\n\n  private lookupFlagValue<T extends JsonValue | FlagValueType>(\n    flagKey: string,\n    defaultValue: T,\n    ctx?: EvaluationContext,\n    logger?: Logger,\n  ): ResolutionDetails<T> {\n    if (!(flagKey in this._flagConfiguration)) {\n      const message = `no flag found with key ${flagKey}`;\n      logger?.debug(message);\n      throw new FlagNotFoundError(message);\n    }\n    const flagSpec: Flag = this._flagConfiguration[flagKey];\n\n    if (flagSpec.disabled) {\n      return { value: defaultValue, reason: StandardResolutionReasons.DISABLED };\n    }\n\n    const isContextEval = ctx && flagSpec?.contextEvaluator;\n    const variant = isContextEval ? flagSpec.contextEvaluator?.(ctx) : flagSpec.defaultVariant;\n\n    const value = variant && flagSpec?.variants[variant];\n\n    if (value === undefined) {\n      const message = `no value associated with variant ${variant}`;\n      logger?.error(message);\n      throw new VariantFoundError(message);\n    }\n\n    return {\n      value: value as T,\n      ...(variant && { variant }),\n      reason: isContextEval ? StandardResolutionReasons.TARGETING_MATCH : StandardResolutionReasons.STATIC,\n    };\n  }\n}\n", "import { NOOP_PROVIDER, Provider } from './provider';\nimport {\n  ManageContext,\n  OpenFeatureCommonAPI,\n  EvaluationContext,\n  objectOrUndefined,\n  stringOrUndefined,\n} from '@openfeature/shared';\nimport { Client, OpenFeatureClient } from './client';\n\n// use a symbol as a key for the global singleton\nconst GLOBAL_OPENFEATURE_API_KEY = Symbol.for('@openfeature/js-sdk/api');\n\ntype OpenFeatureGlobal = {\n  [GLOBAL_OPENFEATURE_API_KEY]?: OpenFeatureAPI;\n};\nconst _globalThis = globalThis as OpenFeatureGlobal;\n\nexport class OpenFeatureAPI extends OpenFeatureCommonAPI<Provider> implements ManageContext<OpenFeatureAPI> {\n  protected _defaultProvider: Provider = NOOP_PROVIDER;\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  private constructor() {\n    super('server');\n  }\n\n  /**\n   * Gets a singleton instance of the OpenFeature API.\n   * @ignore\n   * @returns {OpenFeatureAPI} OpenFeature API\n   */\n  static getInstance(): OpenFeatureAPI {\n    const globalApi = _globalThis[GLOBAL_OPENFEATURE_API_KEY];\n    if (globalApi) {\n      return globalApi;\n    }\n\n    const instance = new OpenFeatureAPI();\n    _globalThis[GLOBAL_OPENFEATURE_API_KEY] = instance;\n    return instance;\n  }\n\n  setContext(context: EvaluationContext): this {\n    this._context = context;\n    return this;\n  }\n\n  getContext(): EvaluationContext {\n    return this._context;\n  }\n\n  /**\n   * A factory function for creating new unnamed OpenFeature clients. Clients can contain\n   * their own state (e.g. logger, hook, context). Multiple clients can be used\n   * to segment feature flag configuration.\n   *\n   * All unnamed clients use the same provider set via {@link this.setProvider setProvider}.\n   * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations\n   * @returns {Client} OpenFeature Client\n   */\n  getClient(context?: EvaluationContext): Client;\n  /**\n   * A factory function for creating new named OpenFeature clients. Clients can contain\n   * their own state (e.g. logger, hook, context). Multiple clients can be used\n   * to segment feature flag configuration.\n   *\n   * If there is already a provider bound to this name via {@link this.setProvider setProvider}, this provider will be used.\n   * Otherwise, the default provider is used until a provider is assigned to that name.\n   * @param {string} name The name of the client\n   * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations\n   * @returns {Client} OpenFeature Client\n   */\n  getClient(name: string, context?: EvaluationContext): Client;\n  /**\n   * A factory function for creating new named OpenFeature clients. Clients can contain\n   * their own state (e.g. logger, hook, context). Multiple clients can be used\n   * to segment feature flag configuration.\n   *\n   * If there is already a provider bound to this name via {@link this.setProvider setProvider}, this provider will be used.\n   * Otherwise, the default provider is used until a provider is assigned to that name.\n   * @param {string} name The name of the client\n   * @param {string} version The version of the client (only used for metadata)\n   * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations\n   * @returns {Client} OpenFeature Client\n   */\n  getClient(name: string, version: string, context?: EvaluationContext): Client;\n  getClient(\n    nameOrContext?: string | EvaluationContext,\n    versionOrContext?: string | EvaluationContext,\n    contextOrUndefined?: EvaluationContext\n  ): Client {\n    const name = stringOrUndefined(nameOrContext);\n    const version = stringOrUndefined(versionOrContext);\n    const context =\n      objectOrUndefined<EvaluationContext>(nameOrContext) ??\n      objectOrUndefined<EvaluationContext>(versionOrContext) ??\n      objectOrUndefined<EvaluationContext>(contextOrUndefined);\n\n    return new OpenFeatureClient(\n      () => this.getProviderForClient(name),\n      () => this.buildAndCacheEventEmitterForClient(name),\n      () => this._logger,\n      { name, version },\n      context\n    );\n  }\n}\n\n/**\n * A singleton instance of the OpenFeature API.\n * @returns {OpenFeatureAPI} OpenFeature API\n */\nexport const OpenFeature = OpenFeatureAPI.getInstance();\n", "import {\n  ClientMetadata,\n  ErrorCode,\n  EvaluationContext,\n  EvaluationDetails,\n  EventHandler,\n  FlagValue,\n  FlagValueType,\n  Hook,\n  HookContext,\n  InternalEventEmitter,\n  JsonValue,\n  Logger,\n  ManageContext,\n  OpenFeatureError,\n  ProviderEvents,\n  ResolutionDetails,\n  SafeLogger,\n  StandardResolutionReasons,\n  statusMatchesEvent\n} from '@openfeature/shared';\nimport { FlagEvaluationOptions } from '../evaluation';\nimport { OpenFeature } from '../open-feature';\nimport { Provider } from '../provider';\nimport { Client } from './client';\n\ntype OpenFeatureClientOptions = {\n  name?: string;\n  version?: string;\n};\n\nexport class OpenFeatureClient implements Client, ManageContext<OpenFeatureClient> {\n  private _context: EvaluationContext;\n  private _hooks: Hook[] = [];\n  private _clientLogger?: Logger;\n\n  constructor(\n    // we always want the client to use the current provider,\n    // so pass a function to always access the currently registered one.\n    private readonly providerAccessor: () => Provider,\n    private readonly emitterAccessor: () => InternalEventEmitter,\n    private readonly globalLogger: () => Logger,\n    private readonly options: OpenFeatureClientOptions,\n    context: EvaluationContext = {}\n  ) {\n    this._context = context;\n  }\n\n  get metadata(): ClientMetadata {\n    return {\n      name: this.options.name,\n      version: this.options.version,\n      providerMetadata: this.providerAccessor().metadata,\n    };\n  }\n\n  addHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>): void {\n    this.emitterAccessor().addHandler(eventType, handler);\n    const shouldRunNow = statusMatchesEvent(eventType, this._provider.status);\n\n    if (shouldRunNow) {\n      // run immediately, we're in the matching state\n      try {\n        handler({ clientName: this.metadata.name, providerName: this._provider.metadata.name });\n      } catch (err) {\n        this._logger?.error('Error running event handler:', err);\n      }\n    }\n  }\n\n  removeHandler<T extends ProviderEvents>(eventType: T, handler: EventHandler<T>) {\n    this.emitterAccessor().removeHandler(eventType, handler);\n  }\n\n  getHandlers(eventType: ProviderEvents) {\n    return this.emitterAccessor().getHandlers(eventType);\n  }\n\n  setLogger(logger: Logger): OpenFeatureClient {\n    this._clientLogger = new SafeLogger(logger);\n    return this;\n  }\n\n  setContext(context: EvaluationContext): OpenFeatureClient {\n    this._context = context;\n    return this;\n  }\n\n  getContext(): EvaluationContext {\n    return this._context;\n  }\n\n  addHooks(...hooks: Hook<FlagValue>[]): OpenFeatureClient {\n    this._hooks = [...this._hooks, ...hooks];\n    return this;\n  }\n\n  getHooks(): Hook<FlagValue>[] {\n    return this._hooks;\n  }\n\n  clearHooks(): OpenFeatureClient {\n    this._hooks = [];\n    return this;\n  }\n\n  async getBooleanValue(\n    flagKey: string,\n    defaultValue: boolean,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions\n  ): Promise<boolean> {\n    return (await this.getBooleanDetails(flagKey, defaultValue, context, options)).value;\n  }\n\n  getBooleanDetails(\n    flagKey: string,\n    defaultValue: boolean,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions\n  ): Promise<EvaluationDetails<boolean>> {\n    return this.evaluate<boolean>(\n      flagKey,\n      this._provider.resolveBooleanEvaluation,\n      defaultValue,\n      'boolean',\n      context,\n      options\n    );\n  }\n\n  async getStringValue<T extends string = string>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions\n  ): Promise<T> {\n    return (await this.getStringDetails<T>(flagKey, defaultValue, context, options)).value;\n  }\n\n  getStringDetails<T extends string = string>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions\n  ): Promise<EvaluationDetails<T>> {\n    return this.evaluate<T>(\n      flagKey,\n      // this isolates providers from our restricted string generic argument.\n      this._provider.resolveStringEvaluation as () => Promise<EvaluationDetails<T>>,\n      defaultValue,\n      'string',\n      context,\n      options\n    );\n  }\n\n  async getNumberValue<T extends number = number>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions\n  ): Promise<T> {\n    return (await this.getNumberDetails(flagKey, defaultValue, context, options)).value;\n  }\n\n  getNumberDetails<T extends number = number>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions\n  ): Promise<EvaluationDetails<T>> {\n    return this.evaluate<T>(\n      flagKey,\n      // this isolates providers from our restricted number generic argument.\n      this._provider.resolveNumberEvaluation as () => Promise<EvaluationDetails<T>>,\n      defaultValue,\n      'number',\n      context,\n      options\n    );\n  }\n\n  async getObjectValue<T extends JsonValue = JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions\n  ): Promise<T> {\n    return (await this.getObjectDetails(flagKey, defaultValue, context, options)).value;\n  }\n\n  getObjectDetails<T extends JsonValue = JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions\n  ): Promise<EvaluationDetails<T>> {\n    return this.evaluate<T>(flagKey, this._provider.resolveObjectEvaluation, defaultValue, 'object', context, options);\n  }\n\n  private async evaluate<T extends FlagValue>(\n    flagKey: string,\n    resolver: (\n      flagKey: string,\n      defaultValue: T,\n      context: EvaluationContext,\n      logger: Logger\n    ) => Promise<ResolutionDetails<T>>,\n    defaultValue: T,\n    flagType: FlagValueType,\n    invocationContext: EvaluationContext = {},\n    options: FlagEvaluationOptions = {}\n  ): Promise<EvaluationDetails<T>> {\n    // merge global, client, and evaluation context\n\n    const allHooks = [\n      ...OpenFeature.getHooks(),\n      ...this.getHooks(),\n      ...(options.hooks || []),\n      ...(this._provider.hooks || []),\n    ];\n    const allHooksReversed = [...allHooks].reverse();\n\n    // merge global and client contexts\n    const mergedContext = {\n      ...OpenFeature.getContext(),\n      ...OpenFeature.getTransactionContext(),\n      ...this._context,\n      ...invocationContext,\n    };\n\n    // this reference cannot change during the course of evaluation\n    // it may be used as a key in WeakMaps\n    const hookContext: Readonly<HookContext> = {\n      flagKey,\n      defaultValue,\n      flagValueType: flagType,\n      clientMetadata: this.metadata,\n      providerMetadata: OpenFeature.providerMetadata,\n      context: mergedContext,\n      logger: this._logger,\n    };\n\n    try {\n      const frozenContext = await this.beforeHooks(allHooks, hookContext, options);\n\n      // run the referenced resolver, binding the provider.\n      const resolution = await resolver.call(this._provider, flagKey, defaultValue, frozenContext, this._logger);\n\n      const evaluationDetails = {\n        ...resolution,\n        flagMetadata: Object.freeze(resolution.flagMetadata ?? {}),\n        flagKey,\n      };\n\n      await this.afterHooks(allHooksReversed, hookContext, evaluationDetails, options);\n\n      return evaluationDetails;\n    } catch (err: unknown) {\n      const errorMessage: string = (err as Error)?.message;\n      const errorCode: ErrorCode = (err as OpenFeatureError)?.code || ErrorCode.GENERAL;\n\n      await this.errorHooks(allHooksReversed, hookContext, err, options);\n\n      return {\n        errorCode,\n        errorMessage,\n        value: defaultValue,\n        reason: StandardResolutionReasons.ERROR,\n        flagMetadata: Object.freeze({}),\n        flagKey,\n      };\n    } finally {\n      await this.finallyHooks(allHooksReversed, hookContext, options);\n    }\n  }\n\n  private async beforeHooks(hooks: Hook[], hookContext: HookContext, options: FlagEvaluationOptions) {\n    for (const hook of hooks) {\n      // freeze the hookContext\n      Object.freeze(hookContext);\n\n      // use Object.assign to avoid modification of frozen hookContext\n      Object.assign(hookContext.context, {\n        ...hookContext.context,\n        ...(await hook?.before?.(hookContext, Object.freeze(options.hookHints))),\n      });\n    }\n\n    // after before hooks, freeze the EvaluationContext.\n    return Object.freeze(hookContext.context);\n  }\n\n  private async afterHooks(\n    hooks: Hook[],\n    hookContext: HookContext,\n    evaluationDetails: EvaluationDetails<FlagValue>,\n    options: FlagEvaluationOptions\n  ) {\n    // run \"after\" hooks sequentially\n    for (const hook of hooks) {\n      await hook?.after?.(hookContext, evaluationDetails, options.hookHints);\n    }\n  }\n\n  private async errorHooks(hooks: Hook[], hookContext: HookContext, err: unknown, options: FlagEvaluationOptions) {\n    // run \"error\" hooks sequentially\n    for (const hook of hooks) {\n      try {\n        await hook?.error?.(hookContext, err, options.hookHints);\n      } catch (err) {\n        this._logger.error(`Unhandled error during 'error' hook: ${err}`);\n        if (err instanceof Error) {\n          this._logger.error(err.stack);\n        }\n        this._logger.error((err as Error)?.stack);\n      }\n    }\n  }\n\n  private async finallyHooks(hooks: Hook[], hookContext: HookContext, options: FlagEvaluationOptions) {\n    // run \"finally\" hooks sequentially\n    for (const hook of hooks) {\n      try {\n        await hook?.finally?.(hookContext, options.hookHints);\n      } catch (err) {\n        this._logger.error(`Unhandled error during 'finally' hook: ${err}`);\n        if (err instanceof Error) {\n          this._logger.error(err.stack);\n        }\n        this._logger.error((err as Error)?.stack);\n      }\n    }\n  }\n\n  private get _provider(): Provider {\n    return this.providerAccessor();\n  }\n\n  private get _logger() {\n    return this._clientLogger || this.globalLogger();\n  }\n}\n"],
  "mappings": "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",
  "names": ["ErrorCode", "ProviderStatus", "ProviderEvents", "import_events", "EventEmitter", "_a", "err"]
}
