import { StandardResolutionReasons, ErrorCode, ParseError, SafeLogger, DefaultLogger } from '@openfeature/core';
import Ajv from 'ajv';
import { sha1 } from 'object-hash';
import { LogicEngine } from 'json-logic-engine';
import { parse as parse$1, compare as compare$1 } from 'semver';
import MurmurHash3 from 'imurmurhash';

var $id$1 = "https://flagd.dev/schema/v0/flags.json";
var $schema$1 = "http://json-schema.org/draft-07/schema#";
var title$1 = "flagd Flag Configuration";
var description$1 = "Defines flags for use in flagd, including typed variants and rules.";
var type$1 = "object";
var properties = {
	flags: {
		title: "Flags",
		description: "Top-level flags object. All flags are defined here.",
		type: "object",
		$comment: "flag objects are one of the 4 flag types defined in definitions",
		additionalProperties: false,
		patternProperties: {
			"^.{1,}$": {
				oneOf: [
					{
						title: "Boolean flag",
						description: "A flag having boolean values.",
						$ref: "#/definitions/booleanFlag"
					},
					{
						title: "String flag",
						description: "A flag having string values.",
						$ref: "#/definitions/stringFlag"
					},
					{
						title: "Numeric flag",
						description: "A flag having numeric values.",
						$ref: "#/definitions/numberFlag"
					},
					{
						title: "Object flag",
						description: "A flag having arbitrary object values.",
						$ref: "#/definitions/objectFlag"
					}
				]
			}
		}
	},
	$evaluators: {
		title: "Evaluators",
		description: "Reusable targeting rules that can be referenced with \"$ref\": \"myRule\" in multiple flags.",
		type: "object",
		additionalProperties: false,
		patternProperties: {
			"^.{1,}$": {
				$comment: "this relative ref means that targeting.json MUST be in the same dir, or available on the same HTTP path",
				$ref: "./targeting.json"
			}
		}
	},
	metadata: {
		title: "Flag Set Metadata",
		description: "Metadata about the flag set, with keys of type string, and values of type boolean, string, or number.",
		properties: {
			flagSetId: {
				description: "The unique identifier for the flag set.",
				type: "string"
			},
			version: {
				description: "The version of the flag set.",
				type: "string"
			}
		},
		$ref: "#/definitions/metadata"
	}
};
var definitions$1 = {
	flag: {
		$comment: "base flag object; no title/description here, allows for better UX, keep it in the overrides",
		type: "object",
		properties: {
			state: {
				title: "Flag State",
				description: "Indicates whether the flag is functional. Disabled flags are treated as if they don't exist.",
				type: "string",
				"enum": [
					"ENABLED",
					"DISABLED"
				]
			},
			defaultVariant: {
				title: "Default Variant",
				description: "The variant to serve if no dynamic targeting applies (including if the targeting returns null).",
				type: "string"
			},
			targeting: {
				$ref: "./targeting.json"
			},
			metadata: {
				title: "Flag Metadata",
				description: "Metadata about an individual feature flag, with keys of type string, and values of type boolean, string, or number.",
				$ref: "#/definitions/metadata"
			}
		},
		required: [
			"state",
			"defaultVariant"
		]
	},
	booleanVariants: {
		type: "object",
		properties: {
			variants: {
				type: "object",
				additionalProperties: false,
				patternProperties: {
					"^.{1,}$": {
						type: "boolean"
					}
				},
				"default": {
					"true": true,
					"false": false
				}
			}
		}
	},
	stringVariants: {
		type: "object",
		properties: {
			variants: {
				type: "object",
				additionalProperties: false,
				patternProperties: {
					"^.{1,}$": {
						type: "string"
					}
				}
			}
		}
	},
	numberVariants: {
		type: "object",
		properties: {
			variants: {
				type: "object",
				additionalProperties: false,
				patternProperties: {
					"^.{1,}$": {
						type: "number"
					}
				}
			}
		}
	},
	objectVariants: {
		type: "object",
		properties: {
			variants: {
				type: "object",
				additionalProperties: false,
				patternProperties: {
					"^.{1,}$": {
						type: "object"
					}
				}
			}
		}
	},
	booleanFlag: {
		$comment: "merge the variants with the base flag to build our typed flags",
		allOf: [
			{
				$ref: "#/definitions/flag"
			},
			{
				$ref: "#/definitions/booleanVariants"
			}
		]
	},
	stringFlag: {
		allOf: [
			{
				$ref: "#/definitions/flag"
			},
			{
				$ref: "#/definitions/stringVariants"
			}
		]
	},
	numberFlag: {
		allOf: [
			{
				$ref: "#/definitions/flag"
			},
			{
				$ref: "#/definitions/numberVariants"
			}
		]
	},
	objectFlag: {
		allOf: [
			{
				$ref: "#/definitions/flag"
			},
			{
				$ref: "#/definitions/objectVariants"
			}
		]
	},
	metadata: {
		type: "object",
		additionalProperties: {
			description: "Any additional key/value pair with value of type boolean, string, or number.",
			type: [
				"string",
				"number",
				"boolean"
			]
		},
		required: [
		]
	}
};
var flagsSchema = {
	$id: $id$1,
	$schema: $schema$1,
	title: title$1,
	description: description$1,
	type: type$1,
	properties: properties,
	definitions: definitions$1
};

var $id = "https://flagd.dev/schema/v0/targeting.json";
var $schema = "http://json-schema.org/draft-07/schema#";
var title = "flagd Targeting";
var description = "Defines targeting logic for flagd; a extension of JSONLogic, including purpose-built feature-flagging operations. Note that this schema applies to top-level objects; no additional properties are supported, including \"$schema\", which means built-in JSON-schema support is not possible in editors. Please use flags.json (which imports this schema) for a rich editor experience.";
var type = "object";
var anyOf = [
	{
		$comment: "we need this to support empty targeting",
		type: "object",
		additionalProperties: false,
		properties: {
		}
	},
	{
		$ref: "#/definitions/anyRule"
	}
];
var definitions = {
	primitive: {
		oneOf: [
			{
				description: "When returned from rules, a null value \"exits\", the targeting, and the \"defaultValue\" is returned, with the reason indicating the targeting did not match.",
				type: "null"
			},
			{
				description: "When returned from rules, booleans are converted to strings (\"true\"/\"false\"), and used to as keys to retrieve the associated value from the \"variants\" object. Be sure that the returned string is present as a key in the variants!",
				type: "boolean"
			},
			{
				description: "When returned from rules, the behavior of numbers is not defined.",
				type: "number"
			},
			{
				description: "When returned from rules, strings are used to as keys to retrieve the associated value from the \"variants\" object. Be sure that the returned string is present as a key in the variants!.",
				type: "string"
			},
			{
				description: "When returned from rules, strings are used to as keys to retrieve the associated value from the \"variants\" object. Be sure that the returned string is present as a key in the variants!.",
				type: "array"
			}
		]
	},
	varRule: {
		title: "Var Operation",
		description: "Retrieve data from the provided data object.",
		type: "object",
		additionalProperties: false,
		properties: {
			"var": {
				anyOf: [
					{
						type: "string",
						description: "flagd automatically injects \"$flagd.timestamp\" (unix epoch) and \"$flagd.flagKey\" (the key of the flag in evaluation) into the context.",
						pattern: "^\\$flagd\\.((timestamp)|(flagKey))$"
					},
					{
						not: {
							$comment: "this is a negated (not) match of \"$flagd.{some-key}\", which is faster and more compatible that a negative lookahead regex",
							type: "string",
							description: "flagd automatically injects \"$flagd.timestamp\" (unix epoch) and \"$flagd.flagKey\" (the key of the flag in evaluation) into the context.",
							pattern: "^\\$flagd\\..*$"
						}
					},
					{
						type: "array",
						$comment: "this is to support the form of var with a default... there seems to be a bug here, where ajv gives a warning (not an error) because maxItems doesn't equal the number of entries in items, though this is valid in this case",
						minItems: 1,
						items: [
							{
								type: "string"
							}
						],
						additionalItems: {
							anyOf: [
								{
									type: "null"
								},
								{
									type: "boolean"
								},
								{
									type: "string"
								},
								{
									type: "number"
								}
							]
						}
					}
				]
			}
		}
	},
	missingRule: {
		title: "Missing Operation",
		description: "Takes an array of data keys to search for (same format as var). Returns an array of any keys that are missing from the data object, or an empty array.",
		type: "object",
		additionalProperties: false,
		properties: {
			missing: {
				type: "array",
				items: {
					type: "string"
				}
			}
		}
	},
	missingSomeRule: {
		title: "Missing-Some Operation",
		description: "Takes a minimum number of data keys that are required, and an array of keys to search for (same format as var or missing). Returns an empty array if the minimum is met, or an array of the missing keys otherwise.",
		type: "object",
		additionalProperties: false,
		properties: {
			missing_some: {
				minItems: 2,
				maxItems: 2,
				type: "array",
				items: [
					{
						type: "number"
					},
					{
						type: "array",
						items: {
							type: "string"
						}
					}
				]
			}
		}
	},
	binaryOrTernaryOp: {
		type: "array",
		minItems: 2,
		maxItems: 3,
		items: {
			$ref: "#/definitions/args"
		}
	},
	binaryOrTernaryRule: {
		type: "object",
		additionalProperties: false,
		properties: {
			substr: {
				title: "Substring Operation",
				description: "Get a portion of a string. Give a positive start position to return everything beginning at that index. Give a negative start position to work backwards from the end of the string, then return everything. Give a positive length to express how many characters to return.",
				$ref: "#/definitions/binaryOrTernaryOp"
			},
			"<": {
				title: "Less-Than/Between Operation. Can be used to test that one value is between two others.",
				$ref: "#/definitions/binaryOrTernaryOp"
			},
			"<=": {
				title: "Less-Than-Or-Equal-To/Between Operation. Can be used to test that one value is between two others.",
				$ref: "#/definitions/binaryOrTernaryOp"
			}
		}
	},
	binaryOp: {
		type: "array",
		minItems: 2,
		maxItems: 2,
		items: {
			$ref: "#/definitions/args"
		}
	},
	binaryRule: {
		title: "Binary Operation",
		description: "Any primitive JSONLogic operation with 2 operands.",
		type: "object",
		additionalProperties: false,
		properties: {
			"if": {
				title: "If Operator",
				description: "The if statement takes 1 or more arguments: a condition (\"if\"), what to do if its true (\"then\", optional, defaults to returning true), and what to do if its false (\"else\", optional, defaults to returning false). Note that the else condition can be used as an else-if statement by adding additional arguments.",
				$ref: "#/definitions/variadicOp"
			},
			"==": {
				title: "Lose Equality Operation",
				description: "Tests equality, with type coercion. Requires two arguments.",
				$ref: "#/definitions/binaryOp"
			},
			"===": {
				title: "Strict Equality Operation",
				description: "Tests strict equality. Requires two arguments.",
				$ref: "#/definitions/binaryOp"
			},
			"!=": {
				title: "Lose Inequality Operation",
				description: "Tests not-equal, with type coercion.",
				$ref: "#/definitions/binaryOp"
			},
			"!==": {
				title: "Strict Inequality Operation",
				description: "Tests strict not-equal.",
				$ref: "#/definitions/binaryOp"
			},
			">": {
				title: "Greater-Than Operation",
				$ref: "#/definitions/binaryOp"
			},
			">=": {
				title: "Greater-Than-Or-Equal-To Operation",
				$ref: "#/definitions/binaryOp"
			},
			"%": {
				title: "Modulo Operation",
				description: "Finds the remainder after the first argument is divided by the second argument.",
				$ref: "#/definitions/binaryOp"
			},
			"/": {
				title: "Division Operation",
				$ref: "#/definitions/binaryOp"
			},
			map: {
				title: "Map Operation",
				description: "Perform an action on every member of an array. Note, that inside the logic being used to map, var operations are relative to the array element being worked on.",
				$ref: "#/definitions/binaryOp"
			},
			filter: {
				title: "Filter Operation",
				description: "Keep only elements of the array that pass a test. Note, that inside the logic being used to filter, var operations are relative to the array element being worked on.",
				$ref: "#/definitions/binaryOp"
			},
			all: {
				title: "All Operation",
				description: "Perform a test on each member of that array, returning true if all pass. Inside the test code, var operations are relative to the array element being tested.",
				$ref: "#/definitions/binaryOp"
			},
			none: {
				title: "None Operation",
				description: "Perform a test on each member of that array, returning true if none pass. Inside the test code, var operations are relative to the array element being tested.",
				$ref: "#/definitions/binaryOp"
			},
			some: {
				title: "Some Operation",
				description: "Perform a test on each member of that array, returning true if some pass. Inside the test code, var operations are relative to the array element being tested.",
				$ref: "#/definitions/binaryOp"
			},
			"in": {
				title: "In Operation",
				description: "If the second argument is an array, tests that the first argument is a member of the array.",
				$ref: "#/definitions/binaryOp"
			}
		}
	},
	reduceRule: {
		type: "object",
		additionalProperties: false,
		properties: {
			reduce: {
				title: "Reduce Operation",
				description: "Combine all the elements in an array into a single value, like adding up a list of numbers. Note, that inside the logic being used to reduce, var operations only have access to an object with a \"current\" and a \"accumulator\".",
				type: "array",
				minItems: 3,
				maxItems: 3,
				items: {
					$ref: "#/definitions/args"
				}
			}
		}
	},
	associativeOp: {
		type: "array",
		minItems: 2,
		items: {
			$ref: "#/definitions/args"
		}
	},
	associativeRule: {
		title: "Mathematically Associative Operation",
		description: "Operation applicable to 2 or more parameters.",
		type: "object",
		additionalProperties: false,
		properties: {
			"*": {
				title: "Multiplication Operation",
				description: "Multiplication; associative, will accept and unlimited amount of arguments.",
				$ref: "#/definitions/associativeOp"
			}
		}
	},
	unaryOp: {
		anyOf: [
			{
				type: "array",
				minItems: 1,
				maxItems: 1,
				items: {
					$ref: "#/definitions/args"
				}
			},
			{
				$ref: "#/definitions/args"
			}
		]
	},
	unaryRule: {
		title: "Unary Operation",
		description: "Any primitive JSONLogic operation with 1 operands.",
		type: "object",
		additionalProperties: false,
		properties: {
			"!": {
				title: "Negation Operation",
				description: "Logical negation (“not”). Takes just one argument.",
				$ref: "#/definitions/unaryOp"
			},
			"!!": {
				title: "Double Negation Operation",
				description: "Double negation, or 'cast to a boolean'. Takes a single argument.",
				$ref: "#/definitions/unaryOp"
			}
		}
	},
	variadicOp: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#/definitions/args"
		}
	},
	variadicRule: {
		$comment: "note < and <= can be used with up to 3 ops (between)",
		type: "object",
		additionalProperties: false,
		properties: {
			or: {
				title: "Or Operation",
				description: "Simple boolean test, with 1 or more arguments. At a more sophisticated level, \"or\" returns the first truthy argument, or the last argument.",
				$ref: "#/definitions/variadicOp"
			},
			and: {
				title: "",
				description: "Simple boolean test, with 1 or more arguments. At a more sophisticated level, \"and\" returns the first falsy argument, or the last argument.",
				$ref: "#/definitions/variadicOp"
			},
			"+": {
				title: "Addition Operation",
				description: "Addition; associative, will accept and unlimited amount of arguments.",
				$ref: "#/definitions/variadicOp"
			},
			"-": {
				title: "Subtraction Operation",
				$ref: "#/definitions/variadicOp"
			},
			max: {
				title: "Maximum Operation",
				description: "Return the maximum from a list of values.",
				$ref: "#/definitions/variadicOp"
			},
			min: {
				title: "Minimum Operation",
				description: "Return the minimum from a list of values.",
				$ref: "#/definitions/variadicOp"
			},
			merge: {
				title: "Merge Operation",
				description: "Takes one or more arrays, and merges them into one array. If arguments aren't arrays, they get cast to arrays.",
				$ref: "#/definitions/variadicOp"
			},
			cat: {
				title: "Concatenate Operation",
				description: "Concatenate all the supplied arguments. Note that this is not a join or implode operation, there is no “glue” string.",
				$ref: "#/definitions/variadicOp"
			}
		}
	},
	stringCompareArg: {
		oneOf: [
			{
				type: "string"
			},
			{
				$ref: "#/definitions/anyRule"
			}
		]
	},
	stringCompareArgs: {
		type: "array",
		minItems: 2,
		maxItems: 2,
		items: {
			$ref: "#/definitions/stringCompareArg"
		}
	},
	stringCompareRule: {
		type: "object",
		additionalProperties: false,
		properties: {
			starts_with: {
				title: "Starts-With Operation",
				description: "The string attribute starts with the specified string value.",
				$ref: "#/definitions/stringCompareArgs"
			},
			ends_with: {
				title: "Ends-With Operation",
				description: "The string attribute ends with the specified string value.",
				$ref: "#/definitions/stringCompareArgs"
			}
		}
	},
	semVerString: {
		title: "Semantic Version String",
		description: "A string representing a valid semantic version expression as per https://semver.org/.",
		type: "string",
		pattern: "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
	},
	ruleSemVer: {
		type: "object",
		additionalProperties: false,
		properties: {
			sem_ver: {
				title: "Semantic Version Operation",
				description: "Attribute matches a semantic version condition. Accepts \"npm-style\" range specifiers: \"=\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"~\" (match minor version), \"^\" (match major version).",
				type: "array",
				minItems: 3,
				maxItems: 3,
				items: [
					{
						oneOf: [
							{
								$ref: "#/definitions/semVerString"
							},
							{
								$ref: "#/definitions/varRule"
							}
						]
					},
					{
						description: "Range specifiers: \"=\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"~\" (match minor version), \"^\" (match major version).",
						"enum": [
							"=",
							"!=",
							">",
							"<",
							">=",
							"<=",
							"~",
							"^"
						]
					},
					{
						oneOf: [
							{
								$ref: "#/definitions/semVerString"
							},
							{
								$ref: "#/definitions/varRule"
							}
						]
					}
				]
			}
		}
	},
	fractionalWeightArg: {
		description: "Distribution for all possible variants, with their associated weighting.",
		type: "array",
		minItems: 1,
		maxItems: 2,
		items: [
			{
				description: "If this bucket is randomly selected, this string is used to as a key to retrieve the associated value from the \"variants\" object.",
				type: "string"
			},
			{
				description: "Weighted distribution for this variant key.",
				type: "number"
			}
		]
	},
	fractionalOp: {
		type: "array",
		minItems: 3,
		$comment: "there seems to be a bug here, where ajv gives a warning (not an error) because maxItems doesn't equal the number of entries in items, though this is valid in this case",
		items: [
			{
				description: "Bucketing value used in pseudorandom assignment; should be unique and stable for each subject of flag evaluation. Defaults to a concatenation of the flagKey and targetingKey.",
				$ref: "#/definitions/anyRule"
			},
			{
				$ref: "#/definitions/fractionalWeightArg"
			},
			{
				$ref: "#/definitions/fractionalWeightArg"
			}
		],
		additionalItems: {
			$ref: "#/definitions/fractionalWeightArg"
		}
	},
	fractionalShorthandOp: {
		type: "array",
		minItems: 2,
		items: {
			$ref: "#/definitions/fractionalWeightArg"
		}
	},
	fractionalRule: {
		type: "object",
		additionalProperties: false,
		properties: {
			fractional: {
				title: "Fractional Operation",
				description: "Deterministic, pseudorandom fractional distribution.",
				oneOf: [
					{
						$ref: "#/definitions/fractionalOp"
					},
					{
						$ref: "#/definitions/fractionalShorthandOp"
					}
				]
			}
		}
	},
	reference: {
		additionalProperties: false,
		type: "object",
		$comment: "patternProperties here is a bit of a hack to prevent this definition from being dereferenced early.",
		patternProperties: {
			"^\\$ref$": {
				title: "Reference",
				description: "A reference to another entity, used for $evaluators (shared rules).",
				type: "string"
			}
		}
	},
	args: {
		oneOf: [
			{
				$ref: "#/definitions/reference"
			},
			{
				$ref: "#/definitions/anyRule"
			},
			{
				$ref: "#/definitions/primitive"
			}
		]
	},
	anyRule: {
		anyOf: [
			{
				$ref: "#/definitions/varRule"
			},
			{
				$ref: "#/definitions/missingRule"
			},
			{
				$ref: "#/definitions/missingSomeRule"
			},
			{
				$ref: "#/definitions/binaryRule"
			},
			{
				$ref: "#/definitions/binaryOrTernaryRule"
			},
			{
				$ref: "#/definitions/associativeRule"
			},
			{
				$ref: "#/definitions/unaryRule"
			},
			{
				$ref: "#/definitions/variadicRule"
			},
			{
				$ref: "#/definitions/reduceRule"
			},
			{
				$ref: "#/definitions/stringCompareRule"
			},
			{
				$ref: "#/definitions/ruleSemVer"
			},
			{
				$ref: "#/definitions/fractionalRule"
			}
		]
	}
};
var targetingSchema = {
	$id: $id,
	$schema: $schema,
	title: title,
	description: description,
	type: type,
	anyOf: anyOf,
	definitions: definitions
};

const flagdPropertyKey = '$flagd';
const flagKeyPropertyKey = 'flagKey';
const timestampPropertyKey = 'timestamp';
const targetingPropertyKey = 'targetingKey';
const loggerSymbol = Symbol.for('flagd.logger');
function getLoggerFromContext(context) {
    const logger = context[loggerSymbol];
    if (!logger) {
        throw new Error('Logger not found in context');
    }
    return logger;
}

const startsWithRule = 'starts_with';
const endsWithRule = 'ends_with';
function startsWith(data, context) {
    return compare(startsWithRule, data, context);
}
function endsWith(data, context) {
    return compare(endsWithRule, data, context);
}
function compare(method, data, context) {
    const logger = getLoggerFromContext(context);
    if (!Array.isArray(data)) {
        logger.debug('Invalid comparison configuration: input is not an array');
        return false;
    }
    if (data.length != 2) {
        logger.debug(`Invalid comparison configuration: invalid array length ${data.length}`);
        return false;
    }
    if (typeof data[0] !== 'string' || typeof data[1] !== 'string') {
        logger.debug('Invalid comparison configuration: array values are not strings');
        return false;
    }
    switch (method) {
        case startsWithRule:
            return data[0].startsWith(data[1]);
        case endsWithRule:
            return data[0].endsWith(data[1]);
        default:
            logger.debug(`Invalid comparison configuration: Invalid method '${method}'`);
            return false;
    }
}

const semVerRule = 'sem_ver';
function semVer(data, context) {
    const logger = getLoggerFromContext(context);
    if (!Array.isArray(data)) {
        logger.debug(`Invalid ${semVerRule} configuration: Expected an array`);
        return false;
    }
    const args = Array.from(data);
    if (args.length != 3) {
        logger.debug(`Invalid ${semVerRule} configuration: Expected 3 arguments, got ${args.length}`);
        return false;
    }
    const semVer1 = parse$1(args[0]);
    const semVer2 = parse$1(args[2]);
    if (!semVer1 || !semVer2) {
        logger.debug(`Invalid ${semVerRule} configuration: Unable to parse semver`);
        return false;
    }
    const operator = String(args[1]);
    const result = compare$1(semVer1, semVer2);
    switch (operator) {
        case '=':
            return result == 0;
        case '!=':
            return result != 0;
        case '<':
            return result < 0;
        case '<=':
            return result <= 0;
        case '>=':
            return result >= 0;
        case '>':
            return result > 0;
        case '^':
            return semVer1.major == semVer2.major;
        case '~':
            return semVer1.major == semVer2.major && semVer1.minor == semVer2.minor;
    }
    return false;
}

const fractionalRule = 'fractional';
function fractional(data, context) {
    const logger = getLoggerFromContext(context);
    if (!Array.isArray(data)) {
        return null;
    }
    const args = Array.from(data);
    if (args.length < 2) {
        logger.debug(`Invalid ${fractionalRule} configuration: Expected at least 2 buckets, got ${args.length}`);
        return null;
    }
    const flagdProperties = context[flagdPropertyKey];
    if (!flagdProperties) {
        logger.debug('Missing flagd properties, cannot perform fractional targeting');
        return null;
    }
    let bucketBy;
    let buckets;
    if (typeof args[0] == 'string') {
        bucketBy = args[0];
        buckets = args.slice(1, args.length);
    }
    else {
        const targetingKey = context[targetingPropertyKey];
        if (!targetingKey) {
            logger.debug('Missing targetingKey property, cannot perform fractional targeting');
            return null;
        }
        bucketBy = `${flagdProperties[flagKeyPropertyKey]}${targetingKey}`;
        buckets = args;
    }
    let bucketingList;
    try {
        bucketingList = toBucketingList(buckets);
    }
    catch (err) {
        logger.debug(`Invalid ${fractionalRule} configuration: `, err.message);
        return null;
    }
    // hash in signed 32 format. Bitwise operation here works in signed 32 hence the conversion
    const hash = new MurmurHash3(bucketBy).result() | 0;
    const bucket = (Math.abs(hash) / 2147483648) * 100;
    let sum = 0;
    for (let i = 0; i < bucketingList.fractions.length; i++) {
        const bucketEntry = bucketingList.fractions[i];
        sum += relativeWeight(bucketingList.totalWeight, bucketEntry.fraction);
        if (sum >= bucket) {
            return bucketEntry.variant;
        }
    }
    return null;
}
function relativeWeight(totalWeight, weight) {
    if (weight == 0) {
        return 0;
    }
    return (weight * 100) / totalWeight;
}
function toBucketingList(from) {
    // extract bucketing options
    const bucketingArray = [];
    let totalWeight = 0;
    for (let i = 0; i < from.length; i++) {
        const entry = from[i];
        if (!Array.isArray(entry)) {
            throw new Error('Invalid bucket entries');
        }
        if (entry.length == 0 || entry.length > 2) {
            throw new Error('Invalid bucketing entry. Requires at least a variant');
        }
        if (typeof entry[0] !== 'string') {
            throw new Error('Bucketing require variant to be present in string format');
        }
        let weight = 1;
        if (entry.length >= 2) {
            if (typeof entry[1] !== 'number') {
                throw new Error('Bucketing require bucketing percentage to be present');
            }
            weight = entry[1];
        }
        bucketingArray.push({ fraction: weight, variant: entry[0] });
        totalWeight += weight;
    }
    return { fractions: bucketingArray, totalWeight };
}

class Targeting {
    constructor(logic, logger) {
        this.logger = logger;
        const engine = new LogicEngine();
        engine.addMethod(startsWithRule, startsWith);
        engine.addMethod(endsWithRule, endsWith);
        engine.addMethod(semVerRule, semVer);
        engine.addMethod(fractionalRule, fractional);
        // JSON logic engine returns a generic Function interface, so we cast it to any
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._logicEngine = engine.build(logic);
    }
    evaluate(flagKey, ctx, logger = this.logger) {
        if (Object.hasOwn(ctx, flagdPropertyKey)) {
            this.logger.debug(`overwriting ${flagdPropertyKey} property in the context`);
        }
        return this._logicEngine(Object.assign(Object.assign({}, ctx), { [flagdPropertyKey]: {
                [flagKeyPropertyKey]: flagKey,
                [timestampPropertyKey]: Math.floor(Date.now() / 1000),
            }, 
            /**
             * Inject the current logger into the context. This is used in custom methods.
             * The symbol is used to prevent collisions with other properties and is omitted
             * when context is serialized.
             */
            [loggerSymbol]: logger }));
    }
}

/**
 * Flagd flag configuration structure for internal reference.
 */
class FeatureFlag {
    constructor(key, flag, logger) {
        var _a;
        this.logger = logger;
        this._key = key;
        this._state = flag['state'];
        this._defaultVariant = flag['defaultVariant'];
        this._variants = new Map(Object.entries(flag['variants']));
        this._metadata = (_a = flag['metadata']) !== null && _a !== void 0 ? _a : {};
        if (flag.targeting && Object.keys(flag.targeting).length > 0) {
            try {
                this._targeting = new Targeting(flag.targeting, logger);
            }
            catch (err) {
                const message = `Invalid targeting configuration for flag '${key}'`;
                this.logger.warn(message);
                this._targetingParseErrorMessage = message;
            }
        }
        this._hash = sha1(flag);
        this.validateStructure();
    }
    get key() {
        return this._key;
    }
    get hash() {
        return this._hash;
    }
    get state() {
        return this._state;
    }
    get defaultVariant() {
        return this._defaultVariant;
    }
    get variants() {
        return this._variants;
    }
    get metadata() {
        return this._metadata;
    }
    evaluate(evalCtx, logger = this.logger) {
        let variant;
        let reason;
        if (this._targetingParseErrorMessage) {
            return {
                reason: StandardResolutionReasons.ERROR,
                errorCode: ErrorCode.PARSE_ERROR,
                errorMessage: this._targetingParseErrorMessage,
                flagMetadata: this.metadata,
            };
        }
        if (!this._targeting) {
            variant = this._defaultVariant;
            reason = StandardResolutionReasons.STATIC;
        }
        else {
            let targetingResolution;
            try {
                targetingResolution = this._targeting.evaluate(this._key, evalCtx, logger);
            }
            catch (e) {
                logger.debug(`Error evaluating targeting rule for flag '${this._key}': ${e.message}`);
                return {
                    reason: StandardResolutionReasons.ERROR,
                    errorCode: ErrorCode.GENERAL,
                    errorMessage: `Error evaluating targeting rule for flag '${this._key}'`,
                    flagMetadata: this.metadata,
                };
            }
            // Return default variant if targeting resolution is null or undefined
            if (targetingResolution === null || targetingResolution === undefined) {
                variant = this._defaultVariant;
                reason = StandardResolutionReasons.DEFAULT;
            }
            else {
                // Obtain resolution in string. This is useful for short-circuiting json logic
                variant = targetingResolution.toString();
                reason = StandardResolutionReasons.TARGETING_MATCH;
            }
        }
        const resolvedValue = this._variants.get(variant);
        if (resolvedValue === undefined) {
            return {
                reason: StandardResolutionReasons.ERROR,
                errorCode: ErrorCode.GENERAL,
                errorMessage: `Variant '${variant}' not found in flag with key '${this._key}'`,
                flagMetadata: this.metadata,
            };
        }
        return {
            value: resolvedValue,
            reason,
            variant,
            flagMetadata: this.metadata,
        };
    }
    validateStructure() {
        // basic validation, ideally this sort of thing is caught by IDEs and other schema validation before we get here
        // consistent with Java/Go and other implementations, we only warn for schema validation, but we fail for this sort of basic structural errors
        if (this._state !== 'ENABLED' && this._state !== 'DISABLED') {
            throw new ParseError(`Invalid flag state: ${JSON.stringify(this._state, undefined, 2)}`);
        }
        if (this._defaultVariant === undefined) {
            // this can be falsy, and int, etc...
            throw new ParseError(`Invalid flag defaultVariant: ${JSON.stringify(this._defaultVariant, undefined, 2)}`);
        }
        if (!this._variants.has(this._defaultVariant)) {
            throw new ParseError(`Default variant ${this._defaultVariant} missing from variants ${JSON.stringify(this._variants, undefined, 2)}`);
        }
    }
}

const ajv = new Ajv({ strict: false });
const validate = ajv.addSchema(targetingSchema).compile(flagsSchema);
const evaluatorKey = '$evaluators';
const bracketReplacer = new RegExp('^[^{]*\\{|}[^}]*$', 'g');
const errorMessages = 'invalid flagd flag configuration';
/**
 * Validate and parse flag configurations.
 * @param flagConfig The flag configuration string.
 * @param strictValidation Validates against the flag and targeting schemas.
 * @param logger The logger to be used for troubleshooting.
 * @returns The parsed flag configurations.
 */
function parse(flagConfig, strictValidation, logger) {
    var _a;
    try {
        const transformed = transform(flagConfig);
        const parsedFlagConfig = JSON.parse(transformed);
        const isValid = validate(parsedFlagConfig);
        if (!isValid) {
            const message = `${errorMessages}: ${JSON.stringify(validate.errors, undefined, 2)}`;
            if (strictValidation) {
                throw new ParseError(message);
            }
            else {
                logger.debug(message);
            }
        }
        const flagMap = new Map();
        const flagSetMetadata = (_a = parsedFlagConfig.metadata) !== null && _a !== void 0 ? _a : {};
        for (const flagsKey in parsedFlagConfig.flags) {
            const flag = parsedFlagConfig.flags[flagsKey];
            flagMap.set(flagsKey, new FeatureFlag(flagsKey, Object.assign(Object.assign({}, flag), { 
                // Flag metadata has higher precedence than flag set metadata
                metadata: Object.assign(Object.assign({}, parsedFlagConfig.metadata), flag.metadata) }), logger));
        }
        return {
            flags: flagMap,
            metadata: flagSetMetadata,
        };
    }
    catch (err) {
        if (err instanceof ParseError) {
            throw err;
        }
        throw new ParseError(errorMessages, { cause: err });
    }
}
// Transform $ref references of flagd configuration
function transform(flagCfg) {
    const evaluators = JSON.parse(flagCfg)[evaluatorKey];
    if (!evaluators) {
        return flagCfg;
    }
    let transformed = flagCfg;
    for (const key in evaluators) {
        const replacer = JSON.stringify(evaluators[key]).replaceAll(bracketReplacer, '');
        const refRegex = new RegExp('"\\$ref":(\\s)*"' + key + '"', 'g');
        transformed = transformed.replaceAll(refRegex, replacer);
    }
    return transformed;
}

/**
 * An implementation of storage contract backed by maps.
 */
class MemoryStorage {
    constructor(logger) {
        this.logger = logger;
        this._flagSetMetadata = {};
        this._flags = new Map();
    }
    getFlag(key) {
        return this._flags.get(key);
    }
    getFlags() {
        return this._flags;
    }
    getFlagSetMetadata() {
        return this._flagSetMetadata;
    }
    setConfigurations(flagConfig, strictValidation = false) {
        const { flags: newFlags, metadata } = parse(flagConfig, strictValidation, this.logger);
        const oldFlags = this._flags;
        const added = [];
        const removed = [];
        const changed = [];
        newFlags.forEach((value, key) => {
            var _a;
            if (!oldFlags.has(key)) {
                added.push(key);
            }
            else if (((_a = oldFlags.get(key)) === null || _a === void 0 ? void 0 : _a.hash) !== value.hash) {
                changed.push(key);
            }
        });
        oldFlags.forEach((_, key) => {
            if (!newFlags.has(key)) {
                removed.push(key);
            }
        });
        this._flags = newFlags;
        this._flagSetMetadata = metadata;
        return [...added, ...removed, ...changed];
    }
}

/**
 * Expose flag configuration setter and flag resolving methods.
 */
class FlagdCore {
    constructor(storage, logger) {
        this._logger = logger ? new SafeLogger(logger) : new DefaultLogger();
        this._storage = storage ? storage : new MemoryStorage(this._logger);
    }
    setConfigurations(flagConfig) {
        return this._storage.setConfigurations(flagConfig);
    }
    getFlag(key) {
        return this._storage.getFlag(key);
    }
    getFlags() {
        return this._storage.getFlags();
    }
    getFlagSetMetadata() {
        return this._storage.getFlagSetMetadata();
    }
    /**
     * Resolve the flag evaluation to a boolean value.
     * @param flagKey - The key of the flag to be evaluated.
     * @param defaultValue - The default value to be returned if the flag is not found.
     * @param evalCtx - The evaluation context to be used for targeting.
     * @param logger - The logger to be used to troubleshoot targeting errors. Overrides the default logger.
     * @returns - The resolved value and the reason for the resolution.
     */
    resolveBooleanEvaluation(flagKey, defaultValue, evalCtx, logger = this._logger) {
        return this.resolve('boolean', flagKey, defaultValue, evalCtx, logger);
    }
    /**
     * Resolve the flag evaluation to a string value.
     * @param flagKey - The key of the flag to be evaluated.
     * @param defaultValue - The default value to be returned if the flag is not found.
     * @param evalCtx - The evaluation context to be used for targeting.
     * @param logger - The logger to be used to troubleshoot targeting errors. Overrides the default logger.
     * @returns - The resolved value and the reason for the resolution.
     */
    resolveStringEvaluation(flagKey, defaultValue, evalCtx, logger = this._logger) {
        return this.resolve('string', flagKey, defaultValue, evalCtx, logger);
    }
    /**
     * Resolve the flag evaluation to a numeric value.
     * @param flagKey - The key of the flag to evaluate.
     * @param defaultValue - The default value to return if the flag is not found or the evaluation fails.
     * @param evalCtx - The evaluation context to be used for targeting.
     * @param logger - The logger to be used to troubleshoot targeting errors. Overrides the default logger.
     * @returns - The resolved value and the reason for the resolution.
     */
    resolveNumberEvaluation(flagKey, defaultValue, evalCtx, logger = this._logger) {
        return this.resolve('number', flagKey, defaultValue, evalCtx, logger);
    }
    /**
     * Resolve the flag evaluation to an object value.
     * @template T - The type of the return value.
     * @param flagKey - The key of the flag to resolve.
     * @param defaultValue - The default value to use if the flag is not found.
     * @param evalCtx - The evaluation context to be used for targeting.
     * @param logger - The logger to be used to troubleshoot targeting errors. Overrides the default logger.
     * @returns - The resolved value and the reason for the resolution.
     */
    resolveObjectEvaluation(flagKey, defaultValue, evalCtx, logger = this._logger) {
        return this.resolve('object', flagKey, defaultValue, evalCtx, logger);
    }
    /**
     * Resolve the flag evaluation for all enabled flags.
     * @param evalCtx - The evaluation context to be used for targeting.
     * @param logger - The logger to be used to troubleshoot targeting errors. Overrides the default logger.
     * @returns - The list of evaluation details for all enabled flags.
     */
    resolveAll(evalCtx = {}, logger = this._logger) {
        const values = [];
        for (const [key, flag] of this.getFlags()) {
            try {
                if (flag.state === 'DISABLED') {
                    continue;
                }
                const result = flag.evaluate(evalCtx, logger);
                if (result.value !== undefined) {
                    values.push(Object.assign(Object.assign({}, result), { flagKey: key }));
                }
                else {
                    logger.debug(`Flag ${key} omitted because ${result.errorCode}: ${result.errorMessage}`);
                }
            }
            catch (e) {
                logger.debug(`Error resolving flag ${key}: ${e.message}`);
            }
        }
        return values;
    }
    /**
     * Resolves the value of a flag based on the specified type.
     * @template T - The type of the flag value.
     * @param {FlagValueType} type - The type of the flag value.
     * @param {string} flagKey - The key of the flag.
     * @param {T} defaultValue - The default value of the flag.
     * @param {EvaluationContext} evalCtx - The evaluation context for targeting rules.
     * @param {Logger} logger - The logger to be used to troubleshoot targeting errors. Overrides the default logger.
     * @returns {ResolutionDetailsWithFlagMetadata<T>} -  The resolved value and the reason for the resolution.
     */
    resolve(type, flagKey, defaultValue, evalCtx = {}, logger = this._logger) {
        const flag = this._storage.getFlag(flagKey);
        if (!flag) {
            return {
                value: defaultValue,
                reason: StandardResolutionReasons.ERROR,
                errorCode: ErrorCode.FLAG_NOT_FOUND,
                errorMessage: `flag '${flagKey}' not found`,
                flagMetadata: this._storage.getFlagSetMetadata(),
            };
        }
        if (flag.state === 'DISABLED') {
            return {
                value: defaultValue,
                reason: StandardResolutionReasons.ERROR,
                errorCode: ErrorCode.FLAG_NOT_FOUND,
                errorMessage: `flag '${flagKey}' is disabled`,
                flagMetadata: flag.metadata,
            };
        }
        const resolution = flag.evaluate(evalCtx, logger);
        /**
         * A resolution without a value represents an error condition. It contains
         * information about the error but requires the default value set.
         */
        if (resolution.value === undefined) {
            return Object.assign(Object.assign({}, resolution), { value: defaultValue });
        }
        if (typeof resolution.value !== type) {
            return {
                value: defaultValue,
                reason: StandardResolutionReasons.ERROR,
                errorCode: ErrorCode.TYPE_MISMATCH,
                errorMessage: `Evaluated type of the flag ${flagKey} does not match. Expected ${type}, got ${typeof resolution.value}`,
                flagMetadata: flag.metadata,
            };
        }
        return Object.assign(Object.assign({}, resolution), { value: resolution.value });
    }
}

const E2E_CLIENT_NAME = 'e2e';
const IMAGE_VERSION = 'v0.5.13';
function getGherkinTestPath(file, modulePath = 'test-harness/gherkin/') {
    return `<rootdir>/../../../../../shared/flagd-core/${modulePath}${file}`;
}

export { E2E_CLIENT_NAME, FeatureFlag, FlagdCore, IMAGE_VERSION, MemoryStorage, getGherkinTestPath };
